{% extends "base.html" %}

{% block content %}
<!-- Photo Lightbox Modal -->
<div id="lightbox" class="lightbox hidden">
    <div class="lightbox-overlay" onclick="closeLightbox()"></div>
    <button class="lightbox-close" onclick="closeLightbox()" title="Close (Esc)">&times;</button>
    <button class="lightbox-nav lightbox-prev" onclick="navigateLightbox(-1)" title="Previous (←)">‹</button>
    <button class="lightbox-nav lightbox-next" onclick="navigateLightbox(1)" title="Next (→)">›</button>

    <div class="lightbox-main">
        <div class="lightbox-content">
            <div class="lightbox-media" id="lightbox-media">
                <!-- Photo or video inserted here -->
            </div>

            <div class="lightbox-album-indicator hidden" id="lightbox-album-indicator">
                <div class="album-indicator-bars" id="lightbox-album-bars"></div>
                <div class="album-indicator-text" id="lightbox-album-text"></div>
            </div>
        </div>

        <div class="lightbox-info">
            <div class="lightbox-meta">
                <div class="lightbox-dates" id="lightbox-dates"></div>
                <div class="lightbox-tags" id="lightbox-tags"></div>
            </div>
            <div class="lightbox-edit-buttons">
                <button id="lightbox-edit-tags" class="lightbox-edit-btn" onclick="openTagEditor()" title="Edit Tags">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                        <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/>
                        <line x1="7" y1="7" x2="7.01" y2="7" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                </button>
                <button id="lightbox-edit-album" class="lightbox-edit-btn hidden" onclick="openAlbumEditor()" title="Edit Album">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                        <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>
                        <path d="m15 5 4 4"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Tag Editor Side Panel -->
    <div id="tag-editor-panel" class="tag-editor-panel">
        <div class="tag-editor-header">
            <h3>Edit Tags</h3>
            <button class="tag-editor-close" onclick="closeTagEditor()">&times;</button>
        </div>

        <div class="tag-editor-body">
            <!-- AI Analysis button -->
            <div class="ai-analysis-section">
                <button id="request-ai-btn" class="btn btn-secondary btn-block" onclick="requestAIAnalysis()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <path d="M12 2a4 4 0 0 1 4 4v2a4 4 0 0 1-8 0V6a4 4 0 0 1 4-4z"/>
                        <path d="M16 14v1a4 4 0 0 1-8 0v-1"/>
                        <circle cx="12" cy="20" r="2"/>
                        <path d="M12 18v-2"/>
                    </svg>
                    Request AI Analysis
                </button>
            </div>

            <!-- Current tags -->
            <div class="current-tags-section">
                <label>Selected:</label>
                <div id="current-tags-container" class="selected-tags-container">
                    <span class="no-tags-hint">No tags selected</span>
                </div>
            </div>

            <div class="tag-search-container">
                <input type="text" id="tag-search" placeholder="Search or add new tag..." autocomplete="off">
            </div>

            <div id="tag-presets-container" class="tag-presets">
                <!-- Categories and tags will be loaded here -->
            </div>

            <div id="add-new-tag-section" class="add-new-tag-section hidden">
                <p>Tag "<span id="new-tag-name"></span>" not found</p>
                <div class="category-select">
                    <label>Select category:</label>
                    <div id="category-buttons" class="category-buttons">
                        <!-- Category buttons will be loaded here -->
                    </div>
                </div>
                <button id="add-new-tag-btn" class="btn btn-small" disabled onclick="addNewTag()">Add to Library</button>
            </div>
        </div>

        <div class="tag-editor-footer">
            <button class="btn btn-secondary" onclick="closeTagEditor()">Cancel</button>
            <button id="save-tags-btn" class="btn" onclick="saveTagChanges()">Save Changes</button>
        </div>
    </div>

    <!-- Album Editor Side Panel -->
    <div id="album-editor-panel" class="album-editor-panel">
        <div class="album-editor-header">
            <h3>Edit Album</h3>
            <button class="album-editor-close" onclick="closeAlbumEditor()">&times;</button>
        </div>

        <div class="album-editor-body">
            <!-- Cover photo selection -->
            <div class="album-editor-section">
                <label>Cover Photo</label>
                <div id="album-cover-grid" class="album-cover-grid">
                    <!-- Cover photo options will be loaded here -->
                </div>
            </div>

            <!-- Current photos (draggable) -->
            <div class="album-editor-section">
                <label>Photos <span id="album-photo-count">(0)</span></label>
                <div id="album-photos-list" class="album-photos-list">
                    <!-- Draggable photo items will be loaded here -->
                </div>
            </div>

            <!-- Add photos button -->
            <div class="album-editor-section">
                <button id="open-add-photos-btn" class="btn btn-secondary btn-block" onclick="openAddPhotosModal()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    Add Photos
                </button>
            </div>
        </div>

        <div class="album-editor-footer">
            <button class="btn btn-secondary" onclick="closeAlbumEditor()">Close</button>
        </div>
    </div>

    <!-- Add Photos Modal -->
    <div id="add-photos-modal" class="add-photos-modal hidden">
        <div class="add-photos-modal-content">
            <div class="add-photos-modal-header">
                <h3>Add Photos to Album</h3>
                <button class="modal-close" onclick="closeAddPhotosModal()">&times;</button>
            </div>
            <div class="add-photos-modal-body">
                <div class="available-photos-grid" id="available-photos-grid">
                    <!-- Photos grid -->
                </div>
                <div class="selected-count" id="selected-photos-count">0 selected</div>
            </div>
            <div class="add-photos-modal-footer">
                <button class="btn btn-secondary" onclick="closeAddPhotosModal()">Cancel</button>
                <button class="btn" id="confirm-add-btn" onclick="confirmAddPhotos()" disabled>Add Selected</button>
            </div>
        </div>
    </div>
</div>

<!-- Breadcrumbs -->
{% if breadcrumbs and breadcrumbs|length > 1 %}
<div class="folder-breadcrumbs" id="folder-breadcrumbs">
    {% for crumb in breadcrumbs %}
        {% if not loop.last %}
        <a href="{{ base_url }}/?folder_id={{ crumb.id }}" onclick="event.preventDefault(); event.stopPropagation(); navigateToFolder('{{ crumb.id }}'); return false;">{{ crumb.name }}</a>
        <span>/</span>
        {% else %}
        <span class="current">{{ crumb.name }}</span>
        {% endif %}
    {% endfor %}
</div>
{% endif %}

<!-- Folder header -->
{% if current_folder %}
<div class="folder-header">
    <div class="folder-header-left">
        <button id="sidebar-toggle" class="sidebar-toggle" title="Toggle folders">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12h18M3 6h18M3 18h18"/>
            </svg>
        </button>
        <h2>{{ current_folder.name }}</h2>
        <!-- Folder action buttons -->
        <div class="folder-actions">
            {% if current_folder.permission in ['owner', 'editor'] %}
            <button id="folder-upload-btn" class="folder-action-btn" title="Upload">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="22" height="22">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
            </button>
            {% endif %}
            <div class="sort-dropdown">
                <button id="sort-btn" class="folder-action-btn" title="Sort by">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="22" height="22">
                        <path d="M7 4v16M7 4l-4 4M7 4l4 4"/>
                        <path d="M17 20V4M17 20l-4-4M17 20l4-4"/>
                    </svg>
                </button>
                <div id="sort-menu" class="sort-menu hidden">
                    <button class="sort-option{% if sort == 'taken' %} active{% endif %}" data-sort="taken">Capture date</button>
                    <button class="sort-option{% if sort == 'uploaded' %} active{% endif %}" data-sort="uploaded">Upload date</button>
                </div>
            </div>
            {% if current_folder.user_id == user.id %}
            <button class="folder-action-btn" onclick="openShareModal('{{ current_folder.id }}')" title="Share">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="22" height="22">
                    <circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
            </button>
            <button class="folder-action-btn" onclick="openEditFolder('{{ current_folder.id }}')" title="Edit folder">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="22" height="22">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                </svg>
            </button>
            {% endif %}
        </div>
        <!-- Selection Menu (hidden by default) -->
        <div id="selection-menu" class="selection-menu hidden">
            <span id="selection-count">0</span>
            <button id="select-all-btn" class="selection-action-btn" title="Select All">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" width="18" height="18">
                    <rect x="5" y="5" width="14" height="14" rx="2" stroke-width="2.5"/>
                    <rect x="2" y="2" width="14" height="14" rx="2" stroke-dasharray="3 2" stroke-width="1.5"/>
                </svg>
            </button>
            <button id="deselect-all-btn" class="selection-action-btn" title="Deselect All">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="18" height="18">
                    <line x1="6" y1="6" x2="18" y2="18"/>
                    <line x1="18" y1="6" x2="6" y2="18"/>
                </svg>
            </button>
            <button id="download-selected-btn" class="selection-action-btn" title="Download">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            </button>
            {% if current_folder.permission in ['owner', 'editor'] %}
            <button id="move-selected-btn" class="selection-action-btn" title="Move to folder">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    <polyline points="12 11 12 17"/>
                    <polyline points="9 14 12 11 15 14"/>
                </svg>
            </button>
            {% endif %}
            <button id="copy-selected-btn" class="selection-action-btn" title="Copy to folder">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                </svg>
            </button>
            {% if current_folder.permission in ['owner', 'editor'] %}
            <button id="ai-selected-btn" class="selection-action-btn" title="Generate AI Tags">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                    <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/>
                    <line x1="7" y1="7" x2="7.01" y2="7" stroke-width="3" stroke-linecap="round"/>
                </svg>
            </button>
            <button id="delete-selected-btn" class="selection-action-btn selection-action-btn--danger" title="Delete">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                    <polyline points="3 6 5 6 21 6"/>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                </svg>
            </button>
            {% endif %}
        </div>
    </div>
    <div class="folder-header-right">
        <!-- Download progress (hidden by default) -->
        <div id="download-progress" class="download-progress hidden">
            <div class="download-progress-bar">
                <div id="download-progress-fill" class="download-progress-fill"></div>
            </div>
            <span id="download-progress-text">Preparing...</span>
        </div>
        <!-- Tag Search -->
        <div class="search-container">
            <input type="text" id="tag-search-input" placeholder="Search..." autocomplete="off">
            <div id="tag-suggestions" class="suggestions hidden"></div>
        </div>
    </div>
</div>
{% endif %}

<!-- Subfolders section (SPA rendered) -->
<div class="subfolders-section" id="subfolders-section" style="display: none;"></div>

<!-- Gallery grid (SPA rendered) -->
<div class="gallery" id="gallery" style="opacity: 0; transition: opacity 0.15s;">
    <!-- Content loaded via API -->
</div>

<!-- Initial load script -->
<script>
(function() {
    const initialFolderId = '{{ initial_folder_id }}';
    if (initialFolderId) {
        // Load initial folder content via SPA (no history entry for initial load)
        navigateToFolder(initialFolderId, false);
    }
})();
</script>
{% endblock %}

{% block scripts %}
<script>
(function() {
    // State - export to window for drag-and-drop
    const selectedPhotos = new Set();
    const selectedAlbums = new Set();
    window.selectedPhotos = selectedPhotos;
    window.selectedAlbums = selectedAlbums;

    let allTags = [];
    let allItems = []; // Store all gallery items for masonry

    // DOM elements
    const gallery = document.getElementById('gallery');
    const selectionMenu = document.getElementById('selection-menu');
    const selectionCount = document.getElementById('selection-count');
    const searchInput = document.getElementById('tag-search-input');
    const suggestions = document.getElementById('tag-suggestions');

    // Exit if not on gallery page
    if (!gallery) return;

    // ============ Masonry Layout ============
    const MIN_COLUMN_WIDTH = 280;
    let masonryBuilt = false;
    let lastColumnCount = 0;
    let lastGalleryWidth = 0;

    function getColumnCount() {
        const width = gallery.clientWidth;
        return Math.max(2, Math.floor(width / MIN_COLUMN_WIDTH));
    }

    function initMasonry() {
        // Collect all items FIRST before any async operations
        allItems = Array.from(gallery.querySelectorAll('.gallery-item'));
        
        // Export to window for SPA navigation compatibility
        window.allItems = allItems;

        // Wait for layout to be ready before building masonry
        // This ensures gallery.clientWidth has correct value
        requestAnimationFrame(() => {
            rebuildMasonry(true); // Force rebuild on init
            // Process photos without stored dimensions (legacy photos)
            processPendingDimensions();
        });
    }

    // Save thumbnail dimensions for legacy photos/albums without stored dimensions
    function processPendingDimensions() {
        const itemsWithoutDimensions = allItems.filter(item => {
            if (item.dataset.thumbWidth) return false; // Already has dimensions
            // Photos without dimensions
            if (item.dataset.itemType === 'photo') return true;
            // Albums with cover photo but no dimensions
            if (item.dataset.itemType === 'album' && item.dataset.coverPhotoId) return true;
            return false;
        });

        if (itemsWithoutDimensions.length === 0) return;

        let pendingCount = itemsWithoutDimensions.length;
        let needsRebuild = false;

        const checkRebuild = () => {
            pendingCount--;
            if (pendingCount <= 0 && needsRebuild) {
                // All dimensions collected, rebuild masonry once
                rebuildMasonry(true);
            }
        };

        itemsWithoutDimensions.forEach(item => {
            const img = item.querySelector('img');
            if (!img) {
                checkRebuild();
                return;
            }

            const isAlbum = item.dataset.itemType === 'album';
            const photoId = isAlbum ? item.dataset.coverPhotoId : item.dataset.photoId;

            const saveAndUpdate = () => {
                if (img.naturalWidth && img.naturalHeight) {
                    // Save to data-attributes for masonry
                    item.dataset.thumbWidth = img.naturalWidth;
                    item.dataset.thumbHeight = img.naturalHeight;

                    // Update aspect-ratio on gallery-link
                    const link = item.querySelector('.gallery-link');
                    if (link) {
                        link.style.aspectRatio = `${img.naturalWidth} / ${img.naturalHeight}`;
                    }

                    // Send to server (fire-and-forget)
                    // For albums, save dimensions to the cover photo
                    saveDimensionsToServer(photoId, img.naturalWidth, img.naturalHeight);
                    needsRebuild = true;
                }
                checkRebuild();
            };

            if (img.complete && img.naturalWidth) {
                saveAndUpdate();
            } else {
                img.addEventListener('load', saveAndUpdate, { once: true });
                img.addEventListener('error', checkRebuild, { once: true });
            }
        });
    }

    async function saveDimensionsToServer(photoId, width, height) {
        try {
            await csrfFetch(`{{ base_url }}/api/photos/${photoId}/dimensions`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ width, height })
            });
        } catch (e) {
            console.warn('Failed to save dimensions for', photoId, e);
        }
    }

    function rebuildMasonry(forceRebuild = false) {
        // Get gallery width (gallery has width: 100% in CSS)
        const galleryWidth = gallery.clientWidth || 800;

        // Calculate columns: minimum 2, based on available width
        const columnCount = Math.max(2, Math.floor(galleryWidth / MIN_COLUMN_WIDTH));
        const columnWidth = galleryWidth / columnCount;

        // Skip rebuild if column count hasn't changed (unless forced or first build)
        if (masonryBuilt && !forceRebuild && columnCount === lastColumnCount) {
            return;
        }

        // Sync allItems with window.allItems (for SPA navigation compatibility)
        // Use window.allItems if defined (even if empty), otherwise fall back to local allItems
        if (window.allItems !== undefined) {
            allItems = window.allItems;
        }

        // Get visible items
        const visibleItems = allItems.filter(item => item.dataset.hidden !== 'true');

        // Also update allItems reference for drag-and-drop
        window.allItems = allItems;

        // Save scroll position before DOM manipulation
        const scrollY = window.scrollY;

        // Clear gallery
        gallery.innerHTML = '';

        // Handle empty state
        if (visibleItems.length === 0 && allItems.length > 0) {
            gallery.innerHTML = '<div class="empty-state"><p>No matches found</p></div>';
            saveNavigationOrder([]);
            masonryBuilt = true;
            lastColumnCount = columnCount;
            lastGalleryWidth = galleryWidth;
            gallery.style.opacity = '1';
            requestAnimationFrame(() => window.scrollTo(0, scrollY));
            return;
        }

        if (visibleItems.length === 0) {
            gallery.innerHTML = '<div class="empty-state"><p>No photos yet</p><p>Click "Upload" to add your first photos</p></div>';
            saveNavigationOrder([]);
            masonryBuilt = true;
            lastColumnCount = columnCount;
            lastGalleryWidth = galleryWidth;
            gallery.style.opacity = '1';
            requestAnimationFrame(() => window.scrollTo(0, scrollY));
            return;
        }

        // Create columns with height tracking
        const columns = [];
        const columnHeights = [];
        for (let i = 0; i < columnCount; i++) {
            const col = document.createElement('div');
            col.className = 'gallery-column';
            columns.push(col);
            columnHeights.push(0);
            gallery.appendChild(col);
        }

        // Track visual order for navigation (row by row reading order)
        const itemPositions = []; // {item, column, row}

        // Distribute items to shortest column for balanced heights
        visibleItems.forEach((item) => {
            // Find shortest column
            let shortestIndex = 0;
            let shortestHeight = columnHeights[0];
            for (let i = 1; i < columnCount; i++) {
                if (columnHeights[i] < shortestHeight) {
                    shortestHeight = columnHeights[i];
                    shortestIndex = i;
                }
            }

            // Track position for navigation
            const row = columns[shortestIndex].children.length;
            itemPositions.push({ item, column: shortestIndex, row });

            columns[shortestIndex].appendChild(item);

            // Update height estimate using data-attributes (preferred) or fallback
            const thumbW = parseInt(item.dataset.thumbWidth) || 0;
            const thumbH = parseInt(item.dataset.thumbHeight) || 0;

            let itemHeight;
            if (thumbW > 0 && thumbH > 0) {
                // Use stored dimensions
                itemHeight = (thumbH / thumbW) * columnWidth;
            } else {
                // Fallback for legacy photos - use square placeholder or loaded image
                const img = item.querySelector('img');
                if (img && img.naturalHeight && img.naturalWidth) {
                    itemHeight = (img.naturalHeight / img.naturalWidth) * columnWidth;
                } else {
                    itemHeight = columnWidth; // Square fallback
                }
            }
            columnHeights[shortestIndex] += itemHeight + 16; // 16 = gap
        });

        // Sort by visual reading order (row first, then column)
        itemPositions.sort((a, b) => {
            if (a.row !== b.row) return a.row - b.row;
            return a.column - b.column;
        });

        // Save navigation order to sessionStorage
        const navOrder = itemPositions.map(p => ({
            type: p.item.dataset.itemType,
            id: p.item.dataset.photoId || p.item.dataset.albumId
        }));
        saveNavigationOrder(navOrder);

        // Mark as built and save column count and width
        masonryBuilt = true;
        lastColumnCount = columnCount;
        lastGalleryWidth = galleryWidth;

        // Show gallery after masonry is built
        gallery.style.opacity = '1';

        // Restore scroll position after DOM rebuild
        requestAnimationFrame(() => {
            window.scrollTo(0, scrollY);
        });
    }

    function saveNavigationOrder(order) {
        sessionStorage.setItem('galleryNavOrder', JSON.stringify(order));
    }

    // Export rebuildMasonry for drag-and-drop
    window.rebuildMasonry = rebuildMasonry;
    
    // Debounced masonry rebuild for image load events (SPA navigation compatibility)
    let imageLoadDebounceTimer;
    window.onGalleryImageLoad = function(img) {
        // Save dimensions to item dataset for masonry calculations
        const item = img.closest('.gallery-item');
        if (item && img.naturalWidth && img.naturalHeight) {
            item.dataset.thumbWidth = img.naturalWidth;
            item.dataset.thumbHeight = img.naturalHeight;
            
            // Update aspect-ratio on gallery-link
            const link = item.querySelector('.gallery-link');
            if (link) {
                link.style.aspectRatio = `${img.naturalWidth} / ${img.naturalHeight}`;
            }
        }
        
        // Debounce masonry rebuild to avoid excessive recalculations
        clearTimeout(imageLoadDebounceTimer);
        imageLoadDebounceTimer = setTimeout(() => {
            rebuildMasonry(true);
        }, 100);
    };
    
    // Helper: Regenerate and upload thumbnail for a safe photo (same as in base.html)
    async function regenerateSafeThumbnail(photoId, safeId) {
        console.log(`[RegenerateThumbnail] Starting for photo ${photoId} in safe ${safeId}`);
        
        try {
            // Fetch the original encrypted file
            const fileResp = await fetch(`{{ base_url }}/api/safe-files/photos/${photoId}/file`);
            if (!fileResp.ok) {
                console.error(`[RegenerateThumbnail] Failed to fetch original file:`, fileResp.status);
                return null;
            }
            
            // Get photo info to determine mime type
            const photoInfoResp = await fetch(`{{ base_url }}/api/photos/${photoId}`);
            let mimeType = 'image/jpeg';
            if (photoInfoResp.ok) {
                const photoInfo = await photoInfoResp.json();
                mimeType = photoInfo.media_type === 'video' ? 'video/mp4' : (photoInfo.mime_type || 'image/jpeg');
            }
            
            // Decrypt the file
            const encryptedBlob = await fileResp.blob();
            const decryptedBlob = await SafeCrypto.decryptFileFromSafe(encryptedBlob, safeId, mimeType);
            
            // Create a File object from the decrypted blob
            const fileName = `photo_${photoId}.${mimeType.split('/')[1] || 'jpg'}`;
            const file = new File([decryptedBlob], fileName, { type: mimeType });
            
            // Generate thumbnail using SafeCrypto's internal method
            let thumbnailBlob;
            let thumbWidth = 0;
            let thumbHeight = 0;
            
            if (file.type.startsWith('video/')) {
                thumbnailBlob = await SafeCrypto._generateVideoThumbnail(file, 400);
            } else {
                thumbnailBlob = await SafeCrypto._generateImageThumbnail(file, 400);
            }
            
            // Get dimensions
            const img = await SafeCrypto._loadImageFromBlob(thumbnailBlob);
            thumbWidth = img.width;
            thumbHeight = img.height;
            
            // Encrypt thumbnail with safe DEK
            const safeDEK = SafeCrypto.getSafeDEK(safeId);
            const thumbData = new Uint8Array(await thumbnailBlob.arrayBuffer());
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encryptedThumbData = await window.crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                safeDEK,
                thumbData
            );
            
            // Combine IV + encrypted data
            const encryptedThumbnail = new Uint8Array(iv.length + encryptedThumbData.byteLength);
            encryptedThumbnail.set(iv);
            encryptedThumbnail.set(new Uint8Array(encryptedThumbData), iv.length);
            
            // Upload thumbnail
            const formData = new FormData();
            formData.append('thumbnail', new Blob([encryptedThumbnail]), 'thumbnail.jpg');
            formData.append('thumb_width', thumbWidth);
            formData.append('thumb_height', thumbHeight);
            
            const uploadResp = await fetch(`{{ base_url }}/api/safe-files/photos/${photoId}/thumbnail`, {
                method: 'POST',
                headers: {
                    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content || ''
                },
                body: formData
            });
            
            if (!uploadResp.ok) {
                console.error(`[RegenerateThumbnail] Failed to upload thumbnail:`, uploadResp.status);
                return null;
            }
            
            console.log(`[RegenerateThumbnail] Successfully regenerated thumbnail for ${photoId}`);
            return new Blob([encryptedThumbnail]);
            
        } catch (err) {
            console.error(`[RegenerateThumbnail] Error:`, err);
            return null;
        }
    }
    
    // Load safe thumbnails client-side (E2E decryption)
    async function loadSafeThumbnails() {
        const safeImages = document.querySelectorAll('img[data-safe-thumbnail]');
        if (safeImages.length === 0) return;
        
        // Placeholder SVG for locked/missing thumbnails
        const placeholderSvg = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%23666" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2" fill="%23333"/><circle cx="8.5" cy="8.5" r="1.5" fill="%23666"/><path d="M21 15l-5-5L5 21" stroke="%23666"/><path d="M7 11l3-3 2 2 4-4" stroke="%23666"/></svg>';
        
        for (const img of safeImages) {
            const photoId = img.dataset.safeThumbnail;
            const safeId = img.dataset.safeId;
            
            if (!photoId || !safeId) continue;
            
            // Check if safe is unlocked
            if (!SafeCrypto.isUnlocked(safeId)) {
                // Show locked placeholder
                img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%23999" stroke-width="2"><rect x="5" y="11" width="14" height="10" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>';
                img.style.opacity = '1';
                if (img.previousElementSibling) {
                    img.previousElementSibling.style.display = 'none';
                }
                continue;
            }
            
            try {
                // Fetch encrypted thumbnail
                const resp = await fetch(`{{ base_url }}/api/safe-files/photos/${photoId}/thumbnail`);
                
                // Check if thumbnail needs regeneration (202 status with X-Regenerate-Thumbnail header)
                if (resp.status === 202 && resp.headers.get('X-Regenerate-Thumbnail') === 'true') {
                    console.log(`[LoadSafeThumbnails] Thumbnail missing for ${photoId}, regenerating...`);
                    
                    // Show loading state
                    img.style.opacity = '0.5';
                    
                    // Regenerate thumbnail
                    const regeneratedBlob = await regenerateSafeThumbnail(photoId, safeId);
                    
                    if (!regeneratedBlob) {
                        console.warn(`[LoadSafeThumbnails] Failed to regenerate thumbnail for ${photoId}`);
                        img.src = placeholderSvg;
                        img.style.opacity = '1';
                        if (img.previousElementSibling) {
                            img.previousElementSibling.style.display = 'none';
                        }
                        onGalleryImageLoad(img);
                        continue;
                    }
                    
                    // Decrypt and display the regenerated thumbnail
                    const decryptedBlob = await SafeCrypto.decryptFileFromSafe(regeneratedBlob, safeId, 'image/jpeg');
                    const url = URL.createObjectURL(decryptedBlob);
                    img.src = url;
                    
                    img.onload = () => {
                        if (img.previousElementSibling) {
                            img.previousElementSibling.style.display = 'none';
                        }
                        img.style.opacity = '1';
                        onGalleryImageLoad(img);
                    };
                    
                    img.onerror = () => {
                        img.src = placeholderSvg;
                        img.style.opacity = '1';
                        if (img.previousElementSibling) {
                            img.previousElementSibling.style.display = 'none';
                        }
                        onGalleryImageLoad(img);
                    };
                    continue;
                }
                
                if (!resp.ok) {
                    console.warn(`Failed to load thumbnail for ${photoId}:`, resp.status);
                    // Show placeholder for missing thumbnail
                    img.src = placeholderSvg;
                    img.style.opacity = '1';
                    if (img.previousElementSibling) {
                        img.previousElementSibling.style.display = 'none';
                    }
                    // Trigger masonry rebuild for placeholder
                    onGalleryImageLoad(img);
                    continue;
                }
                
                // Decrypt thumbnail
                const encryptedBlob = await resp.blob();
                const decryptedBlob = await SafeCrypto.decryptFileFromSafe(encryptedBlob, safeId, 'image/jpeg');
                
                // Create object URL
                const url = URL.createObjectURL(decryptedBlob);
                img.src = url;
                
                // Handle load
                img.onload = () => {
                    if (img.previousElementSibling) {
                        img.previousElementSibling.style.display = 'none';
                    }
                    img.style.opacity = '1';
                    onGalleryImageLoad(img);
                };
                
                img.onerror = () => {
                    console.error(`Failed to load decrypted thumbnail for ${photoId}`);
                    // Show placeholder on error
                    img.src = placeholderSvg;
                    img.style.opacity = '1';
                    if (img.previousElementSibling) {
                        img.previousElementSibling.style.display = 'none';
                    }
                    onGalleryImageLoad(img);
                };
                
            } catch (err) {
                console.error(`Error loading safe thumbnail for ${photoId}:`, err);
                // Show placeholder on error
                img.src = placeholderSvg;
                img.style.opacity = '1';
                if (img.previousElementSibling) {
                    img.previousElementSibling.style.display = 'none';
                }
                onGalleryImageLoad(img);
            }
        }
    }
    
    // Load safe thumbnails on init
    loadSafeThumbnails();

    // Use ResizeObserver to detect gallery width changes
    // This handles: window resize, sidebar loading, zoom changes, etc.
    let resizeObserverTimeout;
    const resizeObserver = new ResizeObserver((entries) => {
        const newWidth = entries[0]?.contentRect.width || 0;
        if (newWidth === 0) return; // Gallery not visible

        // Debounce rapid resize events, then always rebuild
        // rebuildMasonry will skip if column count unchanged
        clearTimeout(resizeObserverTimeout);
        resizeObserverTimeout = setTimeout(() => rebuildMasonry(true), 50);
    });

    // Start observing gallery
    resizeObserver.observe(gallery);

    // Initialize masonry immediately (script is at end of body, DOM is ready)
    initMasonry();

    // Safety: rebuild once more after full page load (catches late sidebar/font loading)
    window.addEventListener('load', () => {
        setTimeout(() => rebuildMasonry(true), 100);
    });

    // Load all tags for autocomplete
    async function loadAllTags() {
        try {
            const resp = await fetch('{{ base_url }}/api/tags/all');
            allTags = await resp.json();
        } catch (e) {
            console.error('Failed to load tags:', e);
        }
    }
    loadAllTags();

    // Restore search from URL on page load
    const urlParams = new URLSearchParams(window.location.search);
    const savedQuery = urlParams.get('q');
    if (savedQuery) {
        searchInput.value = savedQuery;
        sessionStorage.setItem('gallerySearchQuery', savedQuery);
        performSearch();
    } else {
        // Clear sessionStorage if no query in URL
        sessionStorage.removeItem('gallerySearchQuery');
    }

    // Selection handling
    function updateSelectionUI() {
        const count = selectedPhotos.size + selectedAlbums.size;
        if (count > 0) {
            selectionMenu.classList.remove('hidden');
            selectionCount.textContent = count;
        } else {
            selectionMenu.classList.add('hidden');
        }

        // Update visual state of items
        document.querySelectorAll('.gallery-item').forEach(item => {
            const photoId = item.dataset.photoId;
            const albumId = item.dataset.albumId;
            if (selectedPhotos.has(photoId) || selectedAlbums.has(albumId)) {
                item.classList.add('selected');
            } else {
                item.classList.remove('selected');
            }
        });
    }

    // Handle click on select indicator
    gallery.addEventListener('click', (e) => {
        const indicator = e.target.closest('.select-indicator');
        if (indicator) {
            e.preventDefault();
            e.stopPropagation();
            const item = indicator.closest('.gallery-item');
            const itemType = item.dataset.itemType;

            if (itemType === 'album') {
                const albumId = item.dataset.albumId;
                if (selectedAlbums.has(albumId)) {
                    selectedAlbums.delete(albumId);
                } else {
                    selectedAlbums.add(albumId);
                }
            } else {
                const photoId = item.dataset.photoId;
                if (selectedPhotos.has(photoId)) {
                    selectedPhotos.delete(photoId);
                } else {
                    selectedPhotos.add(photoId);
                }
            }
            updateSelectionUI();
        }
    });

    // Select all (only visible items)
    document.getElementById('select-all-btn').addEventListener('click', () => {
        allItems.forEach(item => {
            if (item.dataset.hidden !== 'true') {
                if (item.dataset.itemType === 'album') {
                    selectedAlbums.add(item.dataset.albumId);
                } else {
                    selectedPhotos.add(item.dataset.photoId);
                }
            }
        });
        updateSelectionUI();
    });

    // Deselect all
    document.getElementById('deselect-all-btn').addEventListener('click', () => {
        selectedPhotos.clear();
        selectedAlbums.clear();
        updateSelectionUI();
    });

    // Delete selected
    const deleteBtn = document.getElementById('delete-selected-btn');
    if (deleteBtn) deleteBtn.addEventListener('click', async () => {
        if (selectedPhotos.size === 0 && selectedAlbums.size === 0) return;

        const count = selectedPhotos.size + selectedAlbums.size;
        if (!confirm(`Delete ${count} item(s)? This cannot be undone.`)) return;

        try {
            const resp = await csrfFetch('{{ base_url }}/api/photos/batch-delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    photo_ids: Array.from(selectedPhotos),
                    album_ids: Array.from(selectedAlbums)
                })
            });
            const data = await resp.json();
            if (data.status === 'ok') {
                // Refresh via SPA instead of page reload (keeps safes unlocked)
                selectedPhotos.clear();
                selectedAlbums.clear();
                updateSelectionUI();
                if (window.currentFolderId) {
                    navigateToFolder(window.currentFolderId, false);
                } else {
                    location.reload();
                }
            }
        } catch (e) {
            console.error('Delete failed:', e);
            alert('Failed to delete items');
        }
    });

    // Download selected
    document.getElementById('download-selected-btn').addEventListener('click', async () => {
        if (selectedPhotos.size === 0 && selectedAlbums.size === 0) return;

        const btn = document.getElementById('download-selected-btn');
        const progressContainer = document.getElementById('download-progress');
        const progressFill = document.getElementById('download-progress-fill');
        const progressText = document.getElementById('download-progress-text');

        btn.disabled = true;
        progressContainer.classList.remove('hidden');
        progressFill.style.width = '0%';
        progressText.textContent = 'Preparing...';

        try {
            const resp = await fetch('{{ base_url }}/api/photos/batch-download', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': getCsrfToken()
                },
                body: JSON.stringify({
                    photo_ids: Array.from(selectedPhotos),
                    album_ids: Array.from(selectedAlbums)
                })
            });

            if (!resp.ok) {
                throw new Error('Download failed');
            }

            // Get content length for progress
            const contentLength = resp.headers.get('Content-Length');
            const total = contentLength ? parseInt(contentLength, 10) : 0;

            // Get filename from Content-Disposition header
            const disposition = resp.headers.get('Content-Disposition');
            let filename = 'download';
            if (disposition) {
                const match = disposition.match(/filename="(.+)"/);
                if (match) filename = match[1];
            }

            // Read response with progress
            const reader = resp.body.getReader();
            const chunks = [];
            let received = 0;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                chunks.push(value);
                received += value.length;

                if (total > 0) {
                    const percent = Math.round((received / total) * 100);
                    progressFill.style.width = percent + '%';
                    progressText.textContent = `${percent}%`;
                } else {
                    // Unknown size - show received amount
                    const mb = (received / 1024 / 1024).toFixed(1);
                    progressText.textContent = `${mb} MB`;
                    // Animate progress bar indeterminate-style
                    progressFill.style.width = '50%';
                }
            }

            progressFill.style.width = '100%';
            progressText.textContent = 'Done';

            // Create blob and download
            const blob = new Blob(chunks);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Hide progress after short delay
            setTimeout(() => {
                progressContainer.classList.add('hidden');
            }, 1000);

        } catch (e) {
            console.error('Download failed:', e);
            progressText.textContent = 'Error';
            setTimeout(() => {
                progressContainer.classList.add('hidden');
            }, 2000);
        } finally {
            btn.disabled = false;
        }
    });

    // AI tags for selected
    const aiBtn = document.getElementById('ai-selected-btn');
    if (aiBtn) aiBtn.addEventListener('click', async () => {
        if (selectedPhotos.size === 0 && selectedAlbums.size === 0) return;

        aiBtn.disabled = true;

        try {
            const resp = await csrfFetch('{{ base_url }}/api/photos/batch-ai-tags', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    photo_ids: Array.from(selectedPhotos),
                    album_ids: Array.from(selectedAlbums)
                })
            });
            const data = await resp.json();
            if (data.status === 'ok') {
                alert(`AI tags generated for ${data.processed} photo(s)`);
                selectedPhotos.clear();
                selectedAlbums.clear();
                updateSelectionUI();
            }
        } catch (e) {
            console.error('AI tagging failed:', e);
            alert('Failed to generate AI tags');
        } finally {
            aiBtn.disabled = false;
        }
    });

    // Escape to deselect all
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && (selectedPhotos.size > 0 || selectedAlbums.size > 0)) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            // Don't deselect if lightbox or modals are open
            const lightbox = document.getElementById('lightbox');
            if (lightbox && !lightbox.classList.contains('hidden')) return;

            e.preventDefault();
            selectedPhotos.clear();
            selectedAlbums.clear();
            updateSelectionUI();
        }
    });

    // Tag search with autocomplete
    let debounceTimer;
    searchInput.addEventListener('input', (e) => {
        clearTimeout(debounceTimer);
        const value = e.target.value.trim();

        // Get the last word being typed for suggestions
        const words = value.split(/\s+/);
        const currentWord = words[words.length - 1].toLowerCase();

        // Show suggestions for current word
        if (currentWord.length > 0) {
            debounceTimer = setTimeout(() => {
                const existingWords = words.slice(0, -1).map(w => w.toLowerCase());
                const matches = allTags.filter(t =>
                    t.tag.toLowerCase().includes(currentWord) &&
                    !existingWords.includes(t.tag.toLowerCase())
                ).slice(0, 8);

                if (matches.length > 0) {
                    suggestions.innerHTML = matches.map(t => `
                        <div class="suggestion-item" data-tag="${t.tag}" style="--tag-color: ${t.color}">
                            ${t.tag}
                        </div>
                    `).join('');
                    suggestions.classList.remove('hidden');
                } else {
                    suggestions.classList.add('hidden');
                }
            }, 150);
        } else {
            suggestions.classList.add('hidden');
        }

        // Perform search as user types
        debounceTimer = setTimeout(() => {
            performSearch();
        }, 300);
    });

    // Handle suggestion click - add tag to input
    suggestions.addEventListener('click', (e) => {
        const item = e.target.closest('.suggestion-item');
        if (item) {
            const tag = item.dataset.tag.toLowerCase();
            const value = searchInput.value.trim();
            const words = value.split(/\s+/);
            words[words.length - 1] = tag;
            searchInput.value = words.join(' ') + ' ';
            suggestions.classList.add('hidden');
            searchInput.focus();
            performSearch();
        }
    });

    // Handle Enter key - just perform search
    searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            suggestions.classList.add('hidden');
            performSearch();
        }
    });

    // Hide suggestions on click outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-container')) {
            suggestions.classList.add('hidden');
        }
    });

    // Perform search
    async function performSearch() {
        try {
            const query = searchInput.value.trim();

            // Update URL without reloading
            const url = new URL(window.location);
            if (query) {
                url.searchParams.set('q', query);
                sessionStorage.setItem('gallerySearchQuery', query);
            } else {
                url.searchParams.delete('q');
                sessionStorage.removeItem('gallerySearchQuery');
            }
            window.history.replaceState({}, '', url);

            const resp = await fetch(`{{ base_url }}/api/photos/search?tags=${encodeURIComponent(query)}`);
            const results = await resp.json();

            // Separate matching IDs by type
            const matchingPhotoIds = new Set(results.filter(r => r.type === 'photo').map(r => r.id));
            const matchingAlbumIds = new Set(results.filter(r => r.type === 'album').map(r => r.id));

            const hasQuery = query.length > 0;

            allItems.forEach(item => {
                const itemType = item.dataset.itemType;
                const photoId = item.dataset.photoId;
                const albumId = item.dataset.albumId;

                let matches = false;
                if (!hasQuery) {
                    matches = true;
                } else if (itemType === 'album') {
                    matches = matchingAlbumIds.has(albumId);
                } else {
                    matches = matchingPhotoIds.has(photoId);
                }

                if (matches) {
                    item.dataset.hidden = 'false';
                } else {
                    item.dataset.hidden = 'true';
                    // Deselect hidden items
                    if (itemType === 'album') {
                        selectedAlbums.delete(albumId);
                    } else {
                        selectedPhotos.delete(photoId);
                    }
                }
            });

            // Rebuild masonry with filtered items (force rebuild since visible items changed)
            rebuildMasonry(true);

            // Update selection UI
            updateSelectionUI();
        } catch (e) {
            console.error('Search failed:', e);
        }
    }
})();

// ============ Lightbox Photo Viewer ============
(function() {
    const lightbox = document.getElementById('lightbox');
    const lightboxMedia = document.getElementById('lightbox-media');
    const lightboxTags = document.getElementById('lightbox-tags');
    const lightboxDates = document.getElementById('lightbox-dates');
    const lightboxAlbumIndicator = document.getElementById('lightbox-album-indicator');
    const lightboxAlbumBars = document.getElementById('lightbox-album-bars');
    const lightboxAlbumText = document.getElementById('lightbox-album-text');
    const prevBtn = document.querySelector('.lightbox-prev');
    const nextBtn = document.querySelector('.lightbox-next');

    // Navigation state
    let navOrder = []; // [{type, id}, ...]
    let currentNavIndex = -1;
    let currentPhotoId = null;
    let currentAlbumPhotos = []; // Photo IDs in current album
    let currentAlbumIndex = -1;
    let navigationDirection = 0; // -1 = left (prev), 1 = right (next)

    // Expose current photo ID for tag editor
    Object.defineProperty(window, 'currentLightboxPhotoId', {
        get: () => currentPhotoId
    });

    // Reload current photo (called after tag changes)
    window.reloadCurrentPhoto = function() {
        if (currentPhotoId) {
            loadPhoto(currentPhotoId);
        }
    };

    // Load navigation order from sessionStorage
    function loadNavOrder() {
        const stored = sessionStorage.getItem('galleryNavOrder');
        if (stored) {
            try {
                navOrder = JSON.parse(stored);
            } catch (e) {
                navOrder = [];
            }
        }
    }

    // Open photo in lightbox
    window.openPhoto = async function(photoId) {
        // First check if photo is in a locked safe
        try {
            const resp = await fetch(`{{ base_url }}/api/photos/${photoId}`);
            if (!resp.ok) return;
            const photo = await resp.json();

            // If photo is in a locked safe, open unlock modal first
            if (photo.safe_id && typeof SafeCrypto !== 'undefined' && !SafeCrypto.isUnlocked(photo.safe_id)) {
                console.log('[openPhoto] Photo is in locked safe, opening unlock modal');
                window.pendingSafePhotoId = photoId;
                openSafeUnlockFromLightbox(photo.safe_id);
                return;
            }
        } catch (e) {
            console.error('Failed to check photo safe status:', e);
        }

        // Photo is not in a safe or safe is unlocked - open normally
        loadNavOrder();
        currentPhotoId = photoId;
        currentAlbumPhotos = [];
        currentAlbumIndex = -1;

        // Find position in nav order
        currentNavIndex = navOrder.findIndex(item => item.type === 'photo' && item.id === photoId);

        await loadPhoto(photoId);
        showLightbox();
    };

    // Open album in lightbox (starts from first photo by default)
    window.openAlbum = async function(albumId, startFromEnd = false) {
        loadNavOrder();

        try {
            const resp = await fetch(`{{ base_url }}/api/albums/${albumId}`);
            if (!resp.ok) return;
            const album = await resp.json();

            if (!album.photos || album.photos.length === 0) return;

            currentAlbumPhotos = album.photos.map(p => p.id);
            currentAlbumIndex = startFromEnd ? currentAlbumPhotos.length - 1 : 0;
            currentPhotoId = currentAlbumPhotos[currentAlbumIndex];

            // Find album position in nav order
            currentNavIndex = navOrder.findIndex(item => item.type === 'album' && item.id === albumId);

            await loadPhoto(currentPhotoId);
            showLightbox();
        } catch (e) {
            console.error('Failed to load album:', e);
        }
    };

    // Load photo from safe (client-side decryption)
    async function loadSafePhoto(photo) {
        console.log('[loadSafePhoto] Starting for photo:', photo.id, 'safe_id:', photo.safe_id);
        try {
            // Check if safe is unlocked
            console.log('[loadSafePhoto] Checking if safe is unlocked:', photo.safe_id);
            console.log('[loadSafePhoto] SafeCrypto.isUnlocked:', SafeCrypto.isUnlocked(photo.safe_id));
            console.log('[loadSafePhoto] SafeCrypto available:', !!SafeCrypto);
            
            if (!SafeCrypto.isUnlocked(photo.safe_id)) {
                console.log('[loadSafePhoto] Safe is locked, opening unlock modal');
                // Open unlock modal directly instead of showing message
                openSafeUnlockFromLightbox(photo.safe_id, photo.id);
                return;
            }

            // Show loading state
            lightboxMedia.innerHTML = `<div class="loading-indicator">Decrypting...</div>`;

            // Get encrypted file
            console.log('[loadSafePhoto] Fetching file:', photo.filename);
            const encryptedResp = await fetch(`{{ base_url }}/uploads/${photo.filename}`);
            console.log('[loadSafePhoto] Fetch response:', encryptedResp.status, encryptedResp.ok);
            if (!encryptedResp.ok) {
                throw new Error('Failed to load encrypted file');
            }

            // Check if server returned encrypted file
            const encryptionHeader = encryptedResp.headers.get('X-Encryption');
            console.log('[loadSafePhoto] X-Encryption header:', encryptionHeader);
            
            // Client-side decryption
            console.log('[loadSafePhoto] Getting blob...');
            const responseBlob = await encryptedResp.blob();
            console.log('[loadSafePhoto] Got blob, size:', responseBlob.size);
            
            let blobToDisplay;
            
            if (encryptionHeader !== 'e2e') {
                // Server already decrypted the file (legacy server-encrypted file)
                console.log('[loadSafePhoto] Server returned decrypted file (legacy)');
                blobToDisplay = responseBlob;
            } else {
                // Need client-side decryption
                try {
                    console.log('[loadSafePhoto] Attempting client-side decryption...');
                    blobToDisplay = await SafeCrypto.decryptFileFromSafe(
                        responseBlob,
                        photo.safe_id,
                        photo.media_type || 'image/jpeg'
                    );
                    console.log('[loadSafePhoto] Decryption successful');
                } catch (decryptError) {
                    // Fallback: show encrypted blob (will be garbage but user sees something)
                    console.warn('[loadSafePhoto] Failed to decrypt:', decryptError);
                    lightboxMedia.innerHTML = `
                        <div class="safe-error-message">
                            <p>Failed to decrypt photo</p>
                            <p class="error-details">${decryptError.message}</p>
                            <p>The file may be corrupted or encrypted with a different key.</p>
                        </div>`;
                    return;
                }
            }

            // Create object URL and display
            const url = URL.createObjectURL(blobToDisplay);
            
            if (photo.media_type === 'video') {
                lightboxMedia.innerHTML = `
                    <video src="${url}" controls autoplay loop playsinline class="lightbox-video">
                        Your browser does not support video.
                    </video>`;
            } else {
                lightboxMedia.innerHTML = `
                    <img src="${url}" alt="${photo.original_name}" class="lightbox-image">`;
            }
        } catch (e) {
            console.error('Failed to load safe photo:', e);
            lightboxMedia.innerHTML = `
                <div class="safe-error-message">
                    <p>Failed to load photo</p>
                    <p class="error-details">${e.message}</p>
                    <button onclick="loadPhoto(photo)" class="btn btn-secondary mt-2">Try Loading Raw</button>
                </div>`;
        }
    }

    // Unlock safe from lightbox
    window.openSafeUnlockFromLightbox = function(safeId, photoId) {
        // Find safe name
        const safeItem = document.querySelector(`.folder-item.safe-item[data-safe-id="${safeId}"]`);
        const safeName = safeItem ? safeItem.querySelector('.folder-name').textContent : 'Safe';
        
        // Save the photo ID to open after unlock (if provided or already set)
        if (photoId) {
            window.pendingSafePhotoId = photoId;
        } else if (currentPhotoId && !window.pendingSafePhotoId) {
            window.pendingSafePhotoId = currentPhotoId;
        }
        
        // Open unlock modal
        if (typeof openSafeUnlock === 'function') {
            openSafeUnlock(safeId, safeName, 'password');
        }
    };

    // Load and display photo
    async function loadPhoto(photoId) {
        try {
            const resp = await fetch(`{{ base_url }}/api/photos/${photoId}`);
            if (!resp.ok) {
                console.error('Failed to load photo, status:', resp.status);
                return;
            }
            const photo = await resp.json();

            // Check if photo is in a safe
            if (photo.safe_id && typeof SafeCrypto !== 'undefined') {
                await loadSafePhoto(photo);
                // Still update metadata below
            } else {
                // Update media for regular photos
                if (photo.media_type === 'video') {
                    lightboxMedia.innerHTML = `
                        <video src="{{ base_url }}/uploads/${photo.filename}" controls autoplay loop playsinline class="lightbox-video">
                            Your browser does not support video.
                        </video>`;
                } else {
                    // Progressive loading: show thumbnail first, then load full image
                    const thumbUrl = `{{ base_url }}/thumbnails/${photo.id}.jpg`;
                    const fullUrl = `{{ base_url }}/uploads/${photo.filename}`;

                    lightboxMedia.innerHTML = `
                        <img src="${thumbUrl}" alt="${photo.original_name}" class="lightbox-image">`;

                    // Preload full image in background
                    const fullImg = new Image();
                    fullImg.onload = () => {
                        const currentImg = lightboxMedia.querySelector('.lightbox-image');
                        // Only swap if still viewing the same photo
                        if (currentImg && currentPhotoId === photo.id) {
                            currentImg.src = fullUrl;
                        }
                    };
                    fullImg.src = fullUrl;
                }
            }

            // Update tags
            if (photo.tags && photo.tags.length > 0) {
                lightboxTags.innerHTML = photo.tags.map(t =>
                    `<span class="tag" style="--tag-color: ${t.color}">${t.tag}</span>`
                ).join('');
            } else {
                lightboxTags.innerHTML = '<span class="no-tags">No tags</span>';
            }

            // Update dates
            const formatDate = (dateStr) => {
                if (!dateStr) return null;
                const d = new Date(dateStr);
                return d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit', year: 'numeric' }) +
                       ' ' + d.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
            };
            const takenDate = formatDate(photo.taken_at);
            const uploadedDate = formatDate(photo.uploaded_at);
            let datesHtml = '';
            if (takenDate) {
                datesHtml += `<span class="date-item" title="Capture date"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg> ${takenDate}</span>`;
            }
            if (uploadedDate && uploadedDate !== takenDate) {
                datesHtml += `<span class="date-item" title="Upload date"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg> ${uploadedDate}</span>`;
            }
            lightboxDates.innerHTML = datesHtml;

            // Update album indicator
            if (photo.album) {
                currentAlbumPhotos = photo.album.photo_ids;
                currentAlbumIndex = photo.album.current - 1;

                lightboxAlbumBars.innerHTML = currentAlbumPhotos.map((id, i) =>
                    `<div class="album-bar ${i === currentAlbumIndex ? 'active' : ''}" data-photo-id="${id}"></div>`
                ).join('');
                lightboxAlbumText.textContent = `${photo.album.current} / ${photo.album.total}`;
                lightboxAlbumIndicator.classList.remove('hidden');

                // Add click handlers to album bars
                lightboxAlbumBars.querySelectorAll('.album-bar').forEach(bar => {
                    bar.addEventListener('click', () => {
                        const targetId = bar.dataset.photoId;
                        currentAlbumIndex = currentAlbumPhotos.indexOf(targetId);
                        currentPhotoId = targetId;
                        loadPhoto(targetId);
                    });
                });

                // Update album editor button visibility
                if (window.setCurrentAlbumInfo) {
                    window.setCurrentAlbumInfo(photo.album.id, photo.album.can_edit);
                }
            } else {
                currentAlbumPhotos = [];
                currentAlbumIndex = -1;
                lightboxAlbumIndicator.classList.add('hidden');

                // Hide album editor button
                if (window.setCurrentAlbumInfo) {
                    window.setCurrentAlbumInfo(null, false);
                }
            }

            // Update URL without reload (preserve folder_id from URL)
            const urlFolderId = new URLSearchParams(window.location.search).get('folder_id') || '';
            history.replaceState(null, '', `?folder_id=${urlFolderId}&photo=${photoId}`);

            updateNavButtons();
        } catch (e) {
            console.error('Error loading photo:', e);
        }
    }

    // Update navigation button visibility
    function updateNavButtons() {
        const hasPrev = canNavigate(-1);
        const hasNext = canNavigate(1);
        prevBtn.style.display = hasPrev ? '' : 'none';
        nextBtn.style.display = hasNext ? '' : 'none';
    }

    // Check if can navigate in direction
    function canNavigate(direction) {
        // If in album, check album bounds
        if (currentAlbumPhotos.length > 0) {
            const newIndex = currentAlbumIndex + direction;
            if (newIndex >= 0 && newIndex < currentAlbumPhotos.length) {
                return true;
            }
        }
        // Check main nav order
        const newNavIndex = currentNavIndex + direction;
        return newNavIndex >= 0 && newNavIndex < navOrder.length;
    }

    // Navigate in direction (-1 = prev, 1 = next)
    window.navigateLightbox = function(direction) {
        navigationDirection = direction;

        // If in album, try to navigate within album first
        if (currentAlbumPhotos.length > 0) {
            const newAlbumIndex = currentAlbumIndex + direction;
            if (newAlbumIndex >= 0 && newAlbumIndex < currentAlbumPhotos.length) {
                currentAlbumIndex = newAlbumIndex;
                currentPhotoId = currentAlbumPhotos[currentAlbumIndex];
                loadPhoto(currentPhotoId);
                return;
            }
            // Exit album, move to next/prev in main nav
            currentAlbumPhotos = [];
            currentAlbumIndex = -1;
        }

        // Navigate in main order
        const newNavIndex = currentNavIndex + direction;
        if (newNavIndex < 0 || newNavIndex >= navOrder.length) return;

        currentNavIndex = newNavIndex;
        const nextItem = navOrder[currentNavIndex];

        if (nextItem.type === 'album') {
            // Entering album from navigation:
            // - Going right (forward): start from first photo
            // - Going left (backward): start from last photo
            const startFromEnd = direction < 0;
            openAlbum(nextItem.id, startFromEnd);
        } else {
            currentPhotoId = nextItem.id;
            loadPhoto(currentPhotoId);
        }
    };

    // Show lightbox
    function showLightbox() {
        lightbox.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
    }

    // Close lightbox
    window.closeLightbox = function() {
        lightbox.classList.add('hidden');
        document.body.style.overflow = '';

        // Stop video if playing
        const video = lightboxMedia.querySelector('video');
        if (video) video.pause();

        // Restore URL
        const url = new URL(window.location);
        url.searchParams.delete('photo');
        history.replaceState(null, '', url);
    };

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
        if (lightbox.classList.contains('hidden')) return;
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                navigateLightbox(-1);
                break;
            case 'ArrowRight':
                e.preventDefault();
                navigateLightbox(1);
                break;
            case 'Escape':
                e.preventDefault();
                closeLightbox();
                break;
        }
    });

    // Touch/swipe navigation for mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    let isSwiping = false;
    let isMultiTouch = false; // Track multi-touch for pinch-to-zoom
    const minSwipeDistance = 50;
    const minVerticalSwipeDistance = 80;

    lightbox.addEventListener('touchstart', (e) => {
        // Ignore if touching controls or panels
        if (e.target.closest('.lightbox-info') ||
            e.target.closest('.tag-editor-panel') ||
            e.target.closest('.album-editor-panel') ||
            e.target.closest('.lightbox-nav') ||
            e.target.closest('.lightbox-close') ||
            e.target.closest('.add-photos-modal')) {
            return;
        }

        // Check for multi-touch (pinch-to-zoom)
        if (e.touches.length > 1) {
            isMultiTouch = true;
            isSwiping = false;
            return;
        }

        isMultiTouch = false;
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
        isSwiping = true;
    }, { passive: true });

    // Cancel swipe if additional fingers are added (pinch-to-zoom started)
    lightbox.addEventListener('touchmove', (e) => {
        if (e.touches.length > 1) {
            isMultiTouch = true;
            isSwiping = false;
        }
    }, { passive: true });

    lightbox.addEventListener('touchend', (e) => {
        // Don't process swipe if it was a multi-touch gesture (pinch-to-zoom)
        if (isMultiTouch) {
            // Reset only when all fingers are lifted
            if (e.touches.length === 0) {
                isMultiTouch = false;
            }
            return;
        }

        if (!isSwiping) return;
        isSwiping = false;

        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        handleSwipe();
    }, { passive: true });

    function handleSwipe() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const absDeltaX = Math.abs(deltaX);
        const absDeltaY = Math.abs(deltaY);

        // Determine if horizontal or vertical swipe
        if (absDeltaY > absDeltaX && absDeltaY >= minVerticalSwipeDistance) {
            // Vertical swipe - close lightbox
            const direction = deltaY > 0 ? 'down' : 'up';
            closeLightboxWithAnimation(direction);
        } else if (absDeltaX >= minSwipeDistance && absDeltaX > absDeltaY) {
            // Horizontal swipe - navigate
            if (deltaX > 0) {
                navigateLightboxAnimated(-1);
            } else {
                navigateLightboxAnimated(1);
            }
        }
    }

    // Navigate with slide animation
    function navigateLightboxAnimated(direction) {
        if (!canNavigate(direction)) return;

        const slideOutClass = direction > 0 ? 'slide-out-left' : 'slide-out-right';
        const slideInClass = direction > 0 ? 'slide-in-left' : 'slide-in-right';

        // Slide out current
        lightboxMedia.classList.add(slideOutClass);

        setTimeout(() => {
            lightboxMedia.classList.remove(slideOutClass);
            // Clear old content before loading new to prevent flash
            lightboxMedia.innerHTML = '';
            // Navigate and slide in new
            navigateLightbox(direction);
            lightboxMedia.classList.add(slideInClass);

            setTimeout(() => {
                lightboxMedia.classList.remove(slideInClass);
            }, 250);
        }, 200);
    }

    // Close with vertical slide animation
    function closeLightboxWithAnimation(direction) {
        const slideClass = direction === 'up' ? 'slide-out-up' : 'slide-out-down';
        lightboxMedia.classList.add(slideClass);

        setTimeout(() => {
            lightboxMedia.classList.remove(slideClass);
            closeLightbox();
        }, 200);
    }

    // Check URL for photo param on load
    const urlParams = new URLSearchParams(window.location.search);
    const photoParam = urlParams.get('photo');
    if (photoParam) {
        openPhoto(photoParam);
    }
})();

// ============ Tag Editor ============
(function() {
    const tagEditorPanel = document.getElementById('tag-editor-panel');
    const lightbox = document.getElementById('lightbox');
    const tagSearch = document.getElementById('tag-search');
    const addNewTagSection = document.getElementById('add-new-tag-section');
    const presetsContainer = document.getElementById('tag-presets-container');
    const currentTagsContainer = document.getElementById('current-tags-container');

    let categories = [];
    let editingTags = [];
    let originalTags = [];
    let selectedCategoryId = null;
    let currentEditingPhotoId = null;

    // Open tag editor
    window.openTagEditor = async function() {
        if (!window.currentLightboxPhotoId) return;

        currentEditingPhotoId = window.currentLightboxPhotoId;

        // Get current tags from lightbox
        const resp = await fetch(`{{ base_url }}/api/photos/${currentEditingPhotoId}`);
        const photo = await resp.json();

        originalTags = photo.tags.map(t => ({
            id: t.id,
            name: t.tag,
            category_id: t.category_id,
            color: t.color
        }));
        editingTags = originalTags.map(t => ({ ...t }));

        updateCurrentTagsDisplay();
        tagEditorPanel.classList.add('open');
        lightbox.classList.add('panel-open');
        await loadCategories();
        await loadTagPresets();
        tagSearch.value = '';
        tagSearch.focus();
        addNewTagSection.classList.add('hidden');
    };

    // Close tag editor
    window.closeTagEditor = function() {
        tagEditorPanel.classList.remove('open');
        lightbox.classList.remove('panel-open');
        selectedCategoryId = null;
        editingTags = [];
        originalTags = [];
    };

    // Load tag categories
    async function loadCategories() {
        const response = await fetch('{{ base_url }}/api/tag-categories');
        categories = await response.json();
        renderCategoryButtons();
    }

    // Load tag presets
    async function loadTagPresets(search = "") {
        const response = await fetch(`{{ base_url }}/api/tag-presets?search=${encodeURIComponent(search)}`);
        const data = await response.json();
        renderPresets(data);
        return data;
    }

    // Render preset tags by category
    function renderPresets(presetsData) {
        if (presetsData.length === 0) {
            presetsContainer.innerHTML = '<p class="no-presets">No matching tags found</p>';
            return;
        }

        presetsContainer.innerHTML = presetsData.map(category => `
            <div class="preset-category">
                <h4 style="--cat-color: ${category.color}">${category.name}</h4>
                <div class="preset-tags">
                    ${category.tags.map(tag => {
                        const isSelected = editingTags.some(t => t.name.toLowerCase() === tag.name.toLowerCase());
                        return `
                            <button class="preset-tag ${isSelected ? 'selected' : ''}"
                                    style="--tag-color: ${category.color}"
                                    data-tag-name="${tag.name}"
                                    data-category-id="${category.id}"
                                    data-color="${category.color}">
                                ${tag.name}
                            </button>
                        `;
                    }).join('')}
                </div>
            </div>
        `).join('');

        // Add click handlers
        presetsContainer.querySelectorAll('.preset-tag').forEach(btn => {
            btn.onclick = () => toggleTag(btn.dataset.tagName, parseInt(btn.dataset.categoryId), btn.dataset.color);
        });
    }

    // Render category buttons for new tags
    function renderCategoryButtons() {
        const container = document.getElementById('category-buttons');
        container.innerHTML = categories.map(cat => `
            <button class="category-btn" style="--cat-color: ${cat.color}" data-category-id="${cat.id}">
                ${cat.name}
            </button>
        `).join('');

        container.querySelectorAll('.category-btn').forEach(btn => {
            btn.onclick = () => selectCategory(parseInt(btn.dataset.categoryId));
        });
    }

    // Select category for new tag
    function selectCategory(categoryId) {
        selectedCategoryId = categoryId;
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.classList.toggle('selected', parseInt(btn.dataset.categoryId) === categoryId);
        });
        document.getElementById('add-new-tag-btn').disabled = false;
    }

    // Toggle tag selection
    function toggleTag(tagName, categoryId, color) {
        const index = editingTags.findIndex(t => t.name.toLowerCase() === tagName.toLowerCase());

        if (index === -1) {
            editingTags.push({ name: tagName, category_id: categoryId, color: color });
        } else {
            editingTags.splice(index, 1);
        }

        updateCurrentTagsDisplay();
        updatePresetButtons();
    }

    // Remove tag from editing list
    window.removeTagFromEditing = function(tagName) {
        const index = editingTags.findIndex(t => t.name.toLowerCase() === tagName.toLowerCase());
        if (index !== -1) {
            editingTags.splice(index, 1);
            updateCurrentTagsDisplay();
            updatePresetButtons();
        }
    };

    // Update current tags display
    function updateCurrentTagsDisplay() {
        if (editingTags.length === 0) {
            currentTagsContainer.innerHTML = '<span class="no-tags-hint">No tags selected</span>';
        } else {
            currentTagsContainer.innerHTML = editingTags.map(tag => `
                <span class="selected-tag" style="--tag-color: ${tag.color}">
                    ${tag.name}
                    <button class="tag-remove" onclick="removeTagFromEditing('${tag.name}')">&times;</button>
                </span>
            `).join('');
        }
    }

    // Update preset button states
    function updatePresetButtons() {
        presetsContainer.querySelectorAll('.preset-tag').forEach(btn => {
            const tagName = btn.dataset.tagName;
            const isSelected = editingTags.some(t => t.name.toLowerCase() === tagName.toLowerCase());
            btn.classList.toggle('selected', isSelected);
        });
    }

    // Save tag changes
    window.saveTagChanges = async function() {
        const saveBtn = document.getElementById('save-tags-btn');
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';

        const toAdd = editingTags.filter(et =>
            !originalTags.some(ot => ot.name.toLowerCase() === et.name.toLowerCase())
        );

        const toRemove = originalTags.filter(ot =>
            !editingTags.some(et => et.name.toLowerCase() === ot.name.toLowerCase())
        );

        for (const tag of toRemove) {
            await csrfFetch(`{{ base_url }}/api/photos/${currentEditingPhotoId}/tag/${tag.id}`, { method: 'DELETE' });
        }

        for (const tag of toAdd) {
            await csrfFetch(`{{ base_url }}/api/photos/${currentEditingPhotoId}/tag`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tag: tag.name, category_id: tag.category_id })
            });
        }

        saveBtn.disabled = false;
        saveBtn.textContent = 'Save Changes';
        closeTagEditor();

        // Reload photo in lightbox to show updated tags
        if (window.reloadCurrentPhoto) {
            window.reloadCurrentPhoto();
        }
    };

    // Add new tag to library
    window.addNewTag = async function() {
        const tagName = tagSearch.value.trim();
        if (!tagName || !selectedCategoryId) return;

        if (editingTags.some(t => t.name.toLowerCase() === tagName.toLowerCase())) {
            alert('This tag is already selected');
            return;
        }

        await csrfFetch('{{ base_url }}/api/tag-presets', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: tagName, category_id: selectedCategoryId })
        });

        const category = categories.find(c => c.id === selectedCategoryId);
        editingTags.push({
            name: tagName.toLowerCase(),
            category_id: selectedCategoryId,
            color: category?.color || '#6b7280'
        });

        updateCurrentTagsDisplay();
        tagSearch.value = '';
        addNewTagSection.classList.add('hidden');
        await loadTagPresets();
    };

    // Request AI analysis
    window.requestAIAnalysis = async function() {
        if (!currentEditingPhotoId) return;

        const btn = document.getElementById('request-ai-btn');
        btn.disabled = true;
        btn.innerHTML = 'Analyzing...';

        try {
            const response = await csrfFetch(`{{ base_url }}/api/photos/${currentEditingPhotoId}/ai-tags`, {
                method: 'POST'
            });
            const data = await response.json();

            if (data.status === 'ok') {
                closeTagEditor();
                if (window.reloadCurrentPhoto) {
                    window.reloadCurrentPhoto();
                }
            } else {
                btn.innerHTML = 'Error occurred';
                setTimeout(() => {
                    btn.disabled = false;
                    btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <path d="M12 2a4 4 0 0 1 4 4v2a4 4 0 0 1-8 0V6a4 4 0 0 1 4-4z"/>
                        <path d="M16 14v1a4 4 0 0 1-8 0v-1"/><circle cx="12" cy="20" r="2"/><path d="M12 18v-2"/>
                    </svg> Request AI Analysis`;
                }, 2000);
            }
        } catch (err) {
            btn.innerHTML = 'Error occurred';
            btn.disabled = false;
        }
    };

    // Search functionality
    let searchTimeout;
    tagSearch.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        const query = tagSearch.value.trim();

        searchTimeout = setTimeout(async () => {
            const presets = await loadTagPresets(query);

            if (query.length > 0) {
                const hasExactMatch = presets.some(cat =>
                    cat.tags.some(t => t.name.toLowerCase() === query.toLowerCase())
                );

                if (!hasExactMatch) {
                    document.getElementById('new-tag-name').textContent = query;
                    addNewTagSection.classList.remove('hidden');
                    selectedCategoryId = null;
                    document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('selected'));
                    document.getElementById('add-new-tag-btn').disabled = true;
                } else {
                    addNewTagSection.classList.add('hidden');
                }
            } else {
                addNewTagSection.classList.add('hidden');
            }
        }, 300);
    });

    // Handle ESC key in tag editor
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && tagEditorPanel.classList.contains('open')) {
            e.preventDefault();
            e.stopPropagation();
            closeTagEditor();
        }
    });
})();

// ============ Album Editor ============
(function() {
    const albumEditorPanel = document.getElementById('album-editor-panel');
    const lightbox = document.getElementById('lightbox');
    const editAlbumBtn = document.getElementById('lightbox-edit-album');
    const albumCoverGrid = document.getElementById('album-cover-grid');
    const albumPhotosList = document.getElementById('album-photos-list');
    const albumPhotoCount = document.getElementById('album-photo-count');

    // Add photos modal elements
    const addPhotosModal = document.getElementById('add-photos-modal');
    const availablePhotosGrid = document.getElementById('available-photos-grid');
    const selectedPhotosCount = document.getElementById('selected-photos-count');
    const confirmAddBtn = document.getElementById('confirm-add-btn');
    const openAddPhotosBtn = document.getElementById('open-add-photos-btn');

    // Album editor state
    let currentAlbumId = null;
    let albumPhotos = []; // Current photos in order
    let coverPhotoId = null;
    let availablePhotos = [];
    let selectedToAdd = new Set();
    let canEdit = false;
    let hasChanges = false;

    // Drag state
    let draggedItem = null;
    let draggedIndex = -1;

    // Expose album info for lightbox
    window.setCurrentAlbumInfo = function(albumId, canEditAlbum) {
        currentAlbumId = albumId;
        canEdit = canEditAlbum;
        if (albumId && canEditAlbum) {
            editAlbumBtn.classList.remove('hidden');
        } else {
            editAlbumBtn.classList.add('hidden');
        }
    };

    // Open album editor
    window.openAlbumEditor = async function() {
        if (!currentAlbumId || !canEdit) return;

        try {
            // Load album data
            const albumResp = await fetch(`{{ base_url }}/api/albums/${currentAlbumId}`);
            const album = await albumResp.json();

            albumPhotos = album.photos.map(p => ({
                id: p.id,
                filename: p.filename,
                media_type: p.media_type
            }));
            coverPhotoId = album.cover_photo_id || album.effective_cover_photo_id;

            // Load available photos
            const availResp = await fetch(`{{ base_url }}/api/albums/${currentAlbumId}/available-photos`);
            const availData = await availResp.json();
            availablePhotos = availData.photos || [];
            selectedToAdd.clear();
            hasChanges = false;

            renderCoverGrid();
            renderPhotosList();
            updateOpenAddPhotosBtn();

            albumEditorPanel.classList.add('open');
            lightbox.classList.add('panel-open');
        } catch (e) {
            console.error('Failed to load album:', e);
        }
    };

    // Close album editor
    window.closeAlbumEditor = function() {
        albumEditorPanel.classList.remove('open');
        lightbox.classList.remove('panel-open');

        // Refresh via SPA if changes were made (keeps safes unlocked)
        if (hasChanges) {
            if (window.currentFolderId) {
                navigateToFolder(window.currentFolderId, false);
            } else {
                window.location.reload();
            }
            return;
        }

        currentAlbumId = null;
        albumPhotos = [];
        coverPhotoId = null;
        availablePhotos = [];
        selectedToAdd.clear();
        hasChanges = false;
    };

    // Update add photos button state
    function updateOpenAddPhotosBtn() {
        if (availablePhotos.length === 0) {
            openAddPhotosBtn.disabled = true;
            openAddPhotosBtn.textContent = 'No photos to add';
        } else {
            openAddPhotosBtn.disabled = false;
            openAddPhotosBtn.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                Add Photos (${availablePhotos.length} available)
            `;
        }
    }

    // Render cover photo grid
    function renderCoverGrid() {
        if (albumPhotos.length === 0) {
            albumCoverGrid.innerHTML = '<div class="empty-state">No photos</div>';
            return;
        }

        albumCoverGrid.innerHTML = albumPhotos.map(photo => `
            <div class="album-cover-option ${photo.id === coverPhotoId ? 'selected' : ''}"
                 data-photo-id="${photo.id}"
                 onclick="selectCoverPhoto('${photo.id}')">
                <img src="{{ base_url }}/thumbnails/${photo.id}.jpg" alt="">
            </div>
        `).join('');
    }

    // Select cover photo
    window.selectCoverPhoto = async function(photoId) {
        if (photoId === coverPhotoId) return;

        try {
            const resp = await csrfFetch(`{{ base_url }}/api/albums/${currentAlbumId}/cover`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ photo_id: photoId })
            });

            if (resp.ok) {
                coverPhotoId = photoId;
                hasChanges = true;
                renderCoverGrid();
            }
        } catch (e) {
            console.error('Failed to set cover:', e);
        }
    };

    // Render photos list (sortable)
    function renderPhotosList() {
        albumPhotoCount.textContent = `(${albumPhotos.length})`;

        if (albumPhotos.length === 0) {
            albumPhotosList.innerHTML = '<div class="empty-state">No photos in album</div>';
            return;
        }

        albumPhotosList.innerHTML = albumPhotos.map((photo, index) => `
            <div class="album-photo-item" data-photo-id="${photo.id}" data-index="${index}" draggable="true">
                <div class="drag-handle">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="8" y1="6" x2="16" y2="6"/>
                        <line x1="8" y1="12" x2="16" y2="12"/>
                        <line x1="8" y1="18" x2="16" y2="18"/>
                    </svg>
                </div>
                <img class="photo-thumb" src="{{ base_url }}/thumbnails/${photo.id}.jpg" alt="">
                <span class="photo-info">${index + 1}</span>
                <button class="remove-btn" onclick="removePhotoFromAlbum('${photo.id}')" title="Remove from album">&times;</button>
            </div>
        `).join('');

        setupDragDrop();
    }

    // Setup drag and drop
    function setupDragDrop() {
        const items = albumPhotosList.querySelectorAll('.album-photo-item');

        items.forEach((item, index) => {
            item.addEventListener('dragstart', (e) => {
                draggedItem = item;
                draggedIndex = index;
                item.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                items.forEach(i => i.classList.remove('drag-over'));
                draggedItem = null;
                draggedIndex = -1;
            });

            item.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (draggedItem && draggedItem !== item) {
                    item.classList.add('drag-over');
                }
            });

            item.addEventListener('dragleave', () => {
                item.classList.remove('drag-over');
            });

            item.addEventListener('drop', async (e) => {
                e.preventDefault();
                item.classList.remove('drag-over');

                if (!draggedItem || draggedItem === item) return;

                const targetIndex = parseInt(item.dataset.index);

                // Reorder array
                const [moved] = albumPhotos.splice(draggedIndex, 1);
                albumPhotos.splice(targetIndex, 0, moved);

                // Save new order to server
                const photoIds = albumPhotos.map(p => p.id);
                try {
                    await csrfFetch(`{{ base_url }}/api/albums/${currentAlbumId}/reorder`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ photo_ids: photoIds })
                    });
                    hasChanges = true;
                } catch (e) {
                    console.error('Failed to reorder:', e);
                }

                renderPhotosList();
                renderCoverGrid();
            });
        });
    }

    // Remove photo from album
    window.removePhotoFromAlbum = async function(photoId) {
        try {
            const resp = await csrfFetch(`{{ base_url }}/api/albums/${currentAlbumId}/photos`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ photo_ids: [photoId] })
            });

            if (resp.ok) {
                hasChanges = true;

                // Remove from local state
                albumPhotos = albumPhotos.filter(p => p.id !== photoId);

                // Add to available photos
                availablePhotos.unshift({ id: photoId });

                // Reset cover if removed
                if (coverPhotoId === photoId) {
                    coverPhotoId = albumPhotos.length > 0 ? albumPhotos[0].id : null;
                }

                renderPhotosList();
                renderCoverGrid();
                updateOpenAddPhotosBtn();
            }
        } catch (e) {
            console.error('Failed to remove photo:', e);
        }
    };

    // ========== Add Photos Modal ==========

    // Open add photos modal
    window.openAddPhotosModal = function() {
        if (availablePhotos.length === 0) return;

        selectedToAdd.clear();
        renderAvailablePhotosGrid();
        addPhotosModal.classList.remove('hidden');
    };

    // Close add photos modal
    window.closeAddPhotosModal = function() {
        addPhotosModal.classList.add('hidden');
        selectedToAdd.clear();
    };

    // Render available photos grid
    function renderAvailablePhotosGrid() {
        if (availablePhotos.length === 0) {
            availablePhotosGrid.innerHTML = '<div class="empty-state">No photos available</div>';
            return;
        }

        availablePhotosGrid.innerHTML = availablePhotos.map(p => `
            <div class="available-photo-item ${selectedToAdd.has(p.id) ? 'selected' : ''}"
                 data-photo-id="${p.id}"
                 onclick="togglePhotoSelection('${p.id}')">
                <img src="{{ base_url }}/thumbnails/${p.id}.jpg" alt="">
                <div class="photo-check-indicator">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </div>
            </div>
        `).join('');

        updateSelectionUI();
    }

    // Toggle photo selection
    window.togglePhotoSelection = function(photoId) {
        if (selectedToAdd.has(photoId)) {
            selectedToAdd.delete(photoId);
        } else {
            selectedToAdd.add(photoId);
        }

        // Update visual state
        const item = availablePhotosGrid.querySelector(`[data-photo-id="${photoId}"]`);
        if (item) {
            item.classList.toggle('selected', selectedToAdd.has(photoId));
        }

        updateSelectionUI();
    };

    // Update selection count and button
    function updateSelectionUI() {
        selectedPhotosCount.textContent = selectedToAdd.size > 0
            ? `${selectedToAdd.size} selected`
            : 'None selected';

        confirmAddBtn.disabled = selectedToAdd.size === 0;
        confirmAddBtn.textContent = selectedToAdd.size > 0
            ? `Add ${selectedToAdd.size} Photo${selectedToAdd.size > 1 ? 's' : ''}`
            : 'Add Selected';
    }

    // Confirm adding selected photos
    window.confirmAddPhotos = async function() {
        if (selectedToAdd.size === 0) return;

        const photoIds = Array.from(selectedToAdd);

        try {
            const resp = await csrfFetch(`{{ base_url }}/api/albums/${currentAlbumId}/photos`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ photo_ids: photoIds })
            });

            if (resp.ok) {
                hasChanges = true;

                // Add to album photos
                for (const id of photoIds) {
                    const photo = availablePhotos.find(p => p.id === id);
                    if (photo) {
                        albumPhotos.push({ id: photo.id, filename: photo.filename || `${photo.id}.jpg` });
                    }
                }

                // Remove from available
                availablePhotos = availablePhotos.filter(p => !selectedToAdd.has(p.id));
                selectedToAdd.clear();

                // Close modal and update editor
                closeAddPhotosModal();
                renderPhotosList();
                renderCoverGrid();
                updateOpenAddPhotosBtn();
            }
        } catch (e) {
            console.error('Failed to add photos:', e);
        }
    };

    // Keyboard: ESC to close modal
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !addPhotosModal.classList.contains('hidden')) {
            e.preventDefault();
            closeAddPhotosModal();
        }
    });

    // Handle ESC key in album editor
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && albumEditorPanel.classList.contains('open') && addPhotosModal.classList.contains('hidden')) {
            e.preventDefault();
            e.stopPropagation();
            closeAlbumEditor();
        }
    });
})();

// ============ Move/Copy Items to Folder ============
(function() {
    // Use global currentFolderId from base.html (SPA navigation compatible)
    const getCurrentFolderId = () => window.currentFolderId || new URLSearchParams(window.location.search).get('folder_id');
    const moveBtn = document.getElementById('move-selected-btn');
    const copyBtn = document.getElementById('copy-selected-btn');

    // Need at least copy button to proceed (move is optional for viewers)
    if (!copyBtn) return;

    let pendingAction = null; // 'move' or 'copy'

    // Create folder picker modal
    const pickerModal = document.createElement('div');
    pickerModal.id = 'folder-picker-modal';
    pickerModal.className = 'modal hidden';
    pickerModal.innerHTML = `
        <div class="modal-content folder-picker-content">
            <span class="close">&times;</span>
            <h2 id="folder-picker-title">Move to folder</h2>
            <div class="folder-picker-list" id="folder-picker-list"></div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" id="folder-picker-cancel">Cancel</button>
            </div>
        </div>
    `;
    document.body.appendChild(pickerModal);

    const pickerTitle = document.getElementById('folder-picker-title');
    const pickerList = document.getElementById('folder-picker-list');
    const pickerClose = pickerModal.querySelector('.close');
    const pickerCancel = document.getElementById('folder-picker-cancel');

    // Open picker modal
    function openFolderPicker(action) {
        pendingAction = action;
        pickerTitle.textContent = action === 'move' ? 'Move to folder' : 'Copy to folder';
        renderFolderList();
        pickerModal.classList.remove('hidden');
    }

    // Close picker modal
    function closeFolderPicker() {
        pickerModal.classList.add('hidden');
        pendingAction = null;
    }

    // Render folder list as tree
    function renderFolderList() {
        const folders = window.folderTree || [];
        const editableFolders = folders.filter(f =>
            f.permission === 'owner' || f.permission === 'editor'
        );

        if (editableFolders.length === 0) {
            pickerList.innerHTML = '<div class="no-folders">No folders available</div>';
            return;
        }

        // Build tree recursively
        function buildTree(parentId, level) {
            const children = editableFolders.filter(f => f.parent_id === parentId);
            if (children.length === 0) return '';

            return children.map(folder => {
                const isCurrent = folder.id === getCurrentFolderId();
                const disabled = isCurrent && pendingAction === 'move';
                const indent = level * 20;
                const html = `
                    <div class="folder-picker-item ${disabled ? 'disabled' : ''}"
                         data-folder-id="${folder.id}"
                         style="padding-left: ${12 + indent}px"
                         ${disabled ? 'title="Already in this folder"' : ''}>
                        <svg class="folder-picker-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                        </svg>
                        <span class="folder-picker-name">${escapeHtml(folder.name)}</span>
                        ${isCurrent ? '<span class="folder-picker-current">(current)</span>' : ''}
                    </div>
                `;
                return html + buildTree(folder.id, level + 1);
            }).join('');
        }

        pickerList.innerHTML = buildTree(null, 0);

        // Add click handlers
        pickerList.querySelectorAll('.folder-picker-item:not(.disabled)').forEach(item => {
            item.addEventListener('click', () => {
                const folderId = item.dataset.folderId;
                executeAction(folderId);
            });
        });
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Execute move or copy
    async function executeAction(targetFolderId) {
        const selectedPhotos = window.selectedPhotos || new Set();
        const selectedAlbums = window.selectedAlbums || new Set();

        const photoIds = Array.from(selectedPhotos);
        const albumIds = Array.from(selectedAlbums);

        if (photoIds.length === 0 && albumIds.length === 0) {
            closeFolderPicker();
            return;
        }

        try {
            const endpoint = pendingAction === 'move' ? '{{ base_url }}/api/items/move' : '{{ base_url }}/api/items/copy';
            const resp = await csrfFetch(endpoint, {
                method: pendingAction === 'move' ? 'PUT' : 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    photo_ids: photoIds,
                    album_ids: albumIds,
                    folder_id: targetFolderId
                })
            });

            const data = await resp.json();

            if (data.status === 'ok') {
                if (pendingAction === 'move') {
                    // Remove moved items from DOM
                    photoIds.forEach(id => {
                        const el = document.querySelector(`.gallery-item[data-photo-id="${id}"]`);
                        if (el) el.remove();
                    });
                    albumIds.forEach(id => {
                        const el = document.querySelector(`.gallery-item[data-album-id="${id}"]`);
                        if (el) el.remove();
                    });

                    // Rebuild masonry
                    if (window.rebuildMasonry) window.rebuildMasonry(true);
                }

                // Clear selection
                selectedPhotos.clear();
                selectedAlbums.clear();

                // Update selection UI
                const selectionMenu = document.getElementById('selection-menu');
                if (selectionMenu) selectionMenu.classList.add('hidden');

                document.querySelectorAll('.gallery-item.selected').forEach(el => {
                    el.classList.remove('selected');
                });

                // Update folder counts
                updateFolderCounts();
            }
        } catch (e) {
            console.error(`Failed to ${pendingAction} items:`, e);
            alert(`Failed to ${pendingAction} items. Please try again.`);
        }

        closeFolderPicker();
    }

    // Update folder counts
    async function updateFolderCounts() {
        try {
            const resp = await fetch('{{ base_url }}/api/folders');
            const folders = await resp.json();

            folders.forEach(folder => {
                const countEl = document.querySelector(`.folder-item[data-folder-id="${folder.id}"] .folder-count`);
                if (countEl && folder.photo_count !== undefined) {
                    countEl.textContent = folder.photo_count;
                }
            });
        } catch (e) {
            console.error('Failed to update folder counts:', e);
        }
    }

    // Event listeners
    if (moveBtn) moveBtn.addEventListener('click', () => openFolderPicker('move'));
    copyBtn.addEventListener('click', () => openFolderPicker('copy'));
    pickerClose.addEventListener('click', closeFolderPicker);
    pickerCancel.addEventListener('click', closeFolderPicker);
    pickerModal.addEventListener('click', (e) => {
        if (e.target === pickerModal) closeFolderPicker();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !pickerModal.classList.contains('hidden')) {
            e.preventDefault();
            e.stopPropagation();
            closeFolderPicker();
        }
    });
})();
</script>
{% endblock %}
