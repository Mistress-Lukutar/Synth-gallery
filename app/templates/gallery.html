{% extends "base.html" %}

{% block content %}
<!-- Photo Lightbox Modal -->
<div id="lightbox" class="lightbox hidden">
    <div class="lightbox-overlay" onclick="closeLightbox()"></div>
    <button class="lightbox-close" onclick="closeLightbox()" title="Close (Esc)">&times;</button>
    <button class="lightbox-nav lightbox-prev" onclick="navigateLightbox(-1)" title="Previous (←)">‹</button>
    <button class="lightbox-nav lightbox-next" onclick="navigateLightbox(1)" title="Next (→)">›</button>

    <div class="lightbox-main">
        <div class="lightbox-content">
            <div class="lightbox-media" id="lightbox-media">
                <!-- Photo or video inserted here -->
            </div>

            <div class="lightbox-album-indicator hidden" id="lightbox-album-indicator">
                <div class="album-indicator-bars" id="lightbox-album-bars"></div>
                <div class="album-indicator-text" id="lightbox-album-text"></div>
            </div>
        </div>

        <div class="lightbox-info">
            <div class="lightbox-meta">
                <div class="lightbox-dates" id="lightbox-dates"></div>
                <div class="lightbox-tags" id="lightbox-tags"></div>
            </div>
            <div class="lightbox-actions">
                <a id="lightbox-download" class="btn btn-small" download>Download</a>
                <button id="lightbox-edit-tags" class="btn btn-small btn-secondary" onclick="openTagEditor()">Edit Tags</button>
                <button id="lightbox-edit-album" class="btn btn-small btn-secondary hidden" onclick="openAlbumEditor()">Edit Album</button>
            </div>
        </div>
    </div>

    <!-- Tag Editor Side Panel -->
    <div id="tag-editor-panel" class="tag-editor-panel">
        <div class="tag-editor-header">
            <h3>Edit Tags</h3>
            <button class="tag-editor-close" onclick="closeTagEditor()">&times;</button>
        </div>

        <div class="tag-editor-body">
            <!-- AI Analysis button -->
            <div class="ai-analysis-section">
                <button id="request-ai-btn" class="btn btn-secondary btn-block" onclick="requestAIAnalysis()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <path d="M12 2a4 4 0 0 1 4 4v2a4 4 0 0 1-8 0V6a4 4 0 0 1 4-4z"/>
                        <path d="M16 14v1a4 4 0 0 1-8 0v-1"/>
                        <circle cx="12" cy="20" r="2"/>
                        <path d="M12 18v-2"/>
                    </svg>
                    Request AI Analysis
                </button>
            </div>

            <!-- Current tags -->
            <div class="current-tags-section">
                <label>Selected:</label>
                <div id="current-tags-container" class="selected-tags-container">
                    <span class="no-tags-hint">No tags selected</span>
                </div>
            </div>

            <div class="tag-search-container">
                <input type="text" id="tag-search" placeholder="Search or add new tag..." autocomplete="off">
            </div>

            <div id="tag-presets-container" class="tag-presets">
                <!-- Categories and tags will be loaded here -->
            </div>

            <div id="add-new-tag-section" class="add-new-tag-section hidden">
                <p>Tag "<span id="new-tag-name"></span>" not found</p>
                <div class="category-select">
                    <label>Select category:</label>
                    <div id="category-buttons" class="category-buttons">
                        <!-- Category buttons will be loaded here -->
                    </div>
                </div>
                <button id="add-new-tag-btn" class="btn btn-small" disabled onclick="addNewTag()">Add to Library</button>
            </div>
        </div>

        <div class="tag-editor-footer">
            <button class="btn btn-secondary" onclick="closeTagEditor()">Cancel</button>
            <button id="save-tags-btn" class="btn" onclick="saveTagChanges()">Save Changes</button>
        </div>
    </div>

    <!-- Album Editor Side Panel -->
    <div id="album-editor-panel" class="album-editor-panel">
        <div class="album-editor-header">
            <h3>Edit Album</h3>
            <button class="album-editor-close" onclick="closeAlbumEditor()">&times;</button>
        </div>

        <div class="album-editor-body">
            <!-- Cover photo selection -->
            <div class="album-editor-section">
                <label>Cover Photo</label>
                <div id="album-cover-grid" class="album-cover-grid">
                    <!-- Cover photo options will be loaded here -->
                </div>
            </div>

            <!-- Current photos (draggable) -->
            <div class="album-editor-section">
                <label>Photos <span id="album-photo-count">(0)</span></label>
                <div id="album-photos-list" class="album-photos-list">
                    <!-- Draggable photo items will be loaded here -->
                </div>
            </div>

            <!-- Add photos button -->
            <div class="album-editor-section">
                <button id="open-add-photos-btn" class="btn btn-secondary btn-block" onclick="openAddPhotosModal()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    Add Photos
                </button>
            </div>
        </div>

        <div class="album-editor-footer">
            <button class="btn btn-secondary" onclick="closeAlbumEditor()">Close</button>
        </div>
    </div>

    <!-- Add Photos Modal -->
    <div id="add-photos-modal" class="add-photos-modal hidden">
        <div class="add-photos-modal-content">
            <div class="add-photos-modal-header">
                <h3>Add Photos to Album</h3>
                <button class="modal-close" onclick="closeAddPhotosModal()">&times;</button>
            </div>
            <div class="add-photos-modal-body">
                <div class="available-photos-grid" id="available-photos-grid">
                    <!-- Photos grid -->
                </div>
                <div class="selected-count" id="selected-photos-count">0 selected</div>
            </div>
            <div class="add-photos-modal-footer">
                <button class="btn btn-secondary" onclick="closeAddPhotosModal()">Cancel</button>
                <button class="btn" id="confirm-add-btn" onclick="confirmAddPhotos()" disabled>Add Selected</button>
            </div>
        </div>
    </div>
</div>

<!-- Breadcrumbs -->
{% if breadcrumbs and breadcrumbs|length > 1 %}
<div class="folder-breadcrumbs">
    {% for crumb in breadcrumbs %}
        {% if not loop.last %}
        <a href="/?folder_id={{ crumb.id }}">{{ crumb.name }}</a>
        <span>/</span>
        {% else %}
        <span class="current">{{ crumb.name }}</span>
        {% endif %}
    {% endfor %}
</div>
{% endif %}

<!-- Folder header -->
{% if current_folder %}
<div class="folder-header">
    <h2>{{ current_folder.name }}</h2>
    <div class="folder-header-actions">
        {% if current_folder.user_id == user.id %}
        <button class="btn-share" onclick="openShareModal('{{ current_folder.id }}')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                <circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/>
                <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
            </svg>
            Share
        </button>
        {% endif %}
    </div>
</div>
{% endif %}

<div class="gallery" id="gallery">
    {% if items %}
        {% for item in items %}
            {% if item.type == 'folder' %}
            <!-- Subfolder card -->
            <div class="gallery-item folder-item-card"
                 data-folder-id="{{ item.id }}"
                 data-item-type="folder"
                 onclick="window.location.href='/?folder_id={{ item.id }}'">
                <svg class="folder-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                </svg>
                <span class="folder-card-name">{{ item.name }}</span>
                <span class="folder-card-count">{{ item.photo_count }}</span>
            </div>
            {% elif item.type == 'album' %}
            <div class="gallery-item album-item" data-album-id="{{ item.id }}" data-item-type="album">
                <div class="gallery-link" onclick="openAlbum('{{ item.id }}')">
                    {% if item.cover_photo_id %}
                    <img src="/thumbnails/{{ item.cover_photo_id }}.jpg"
                         alt="{{ item.name }}"
                         loading="lazy">
                    {% else %}
                    <div class="album-placeholder">
                        <span>Empty Album</span>
                    </div>
                    {% endif %}
                    <div class="album-badge">
                        <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                            <rect x="3" y="3" width="7" height="7" rx="1"/>
                            <rect x="14" y="3" width="7" height="7" rx="1"/>
                            <rect x="3" y="14" width="7" height="7" rx="1"/>
                            <rect x="14" y="14" width="7" height="7" rx="1"/>
                        </svg>
                        <span>{{ item.photo_count }}</span>
                    </div>
                </div>
                <div class="select-indicator" title="Select">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </div>
            </div>
            {% else %}
            <div class="gallery-item" data-photo-id="{{ item.id }}" data-item-type="photo" data-media-type="{{ item.media_type or 'image' }}">
                <div class="gallery-link" onclick="openPhoto('{{ item.id }}')">
                    <img src="/thumbnails/{{ item.id }}.jpg"
                         alt="{{ item.original_name }}"
                         loading="lazy">
                    {% if item.media_type == 'video' %}
                    <div class="video-badge">
                        <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                    </div>
                    {% endif %}
                </div>
                <div class="select-indicator" title="Select">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </div>
            </div>
            {% endif %}
        {% endfor %}
    {% else %}
        <div class="empty-state">
            <p>No photos yet</p>
            <p>Click "Upload" or drag & drop to add your first photos</p>
        </div>
    {% endif %}
</div>
{% endblock %}

{% block scripts %}
<script>
(function() {
    // State
    const selectedPhotos = new Set();
    const selectedAlbums = new Set();
    let allTags = [];
    let allItems = []; // Store all gallery items for masonry

    // DOM elements
    const gallery = document.getElementById('gallery');
    const selectionMenu = document.getElementById('selection-menu');
    const selectionCount = document.getElementById('selection-count');
    const searchInput = document.getElementById('tag-search-input');
    const suggestions = document.getElementById('tag-suggestions');

    // Exit if not on gallery page
    if (!gallery) return;

    // ============ Masonry Layout ============
    const MIN_COLUMN_WIDTH = 280;

    function getColumnCount() {
        const width = gallery.clientWidth;
        return Math.max(2, Math.floor(width / MIN_COLUMN_WIDTH));
    }

    function initMasonry() {
        // Collect all items on first run
        if (allItems.length === 0) {
            allItems = Array.from(gallery.querySelectorAll('.gallery-item'));
        }

        // Wait for images to load, then build masonry
        const images = gallery.querySelectorAll('img');
        let loadedCount = 0;
        const totalImages = images.length;

        if (totalImages === 0) {
            rebuildMasonry();
            return;
        }

        const onImageLoad = () => {
            loadedCount++;
            if (loadedCount >= totalImages) {
                rebuildMasonry();
            }
        };

        images.forEach(img => {
            if (img.complete) {
                onImageLoad();
            } else {
                img.addEventListener('load', onImageLoad);
                img.addEventListener('error', onImageLoad);
            }
        });

        // Fallback: build anyway after timeout
        setTimeout(rebuildMasonry, 500);
    }

    function rebuildMasonry() {
        const columnCount = getColumnCount();

        // Get visible items
        const visibleItems = allItems.filter(item => item.dataset.hidden !== 'true');

        // Clear gallery
        gallery.innerHTML = '';

        // Handle empty state
        if (visibleItems.length === 0 && allItems.length > 0) {
            gallery.innerHTML = '<div class="empty-state"><p>No matches found</p></div>';
            saveNavigationOrder([]);
            return;
        }

        if (visibleItems.length === 0) {
            gallery.innerHTML = '<div class="empty-state"><p>No photos yet</p><p>Click "Upload" or drag & drop to add your first photos</p></div>';
            saveNavigationOrder([]);
            return;
        }

        // Create columns with height tracking
        const columns = [];
        const columnHeights = [];
        for (let i = 0; i < columnCount; i++) {
            const col = document.createElement('div');
            col.className = 'gallery-column';
            columns.push(col);
            columnHeights.push(0);
            gallery.appendChild(col);
        }

        // Track visual order for navigation (row by row reading order)
        const itemPositions = []; // {item, column, row}

        // Distribute items to shortest column for balanced heights
        visibleItems.forEach((item) => {
            // Find shortest column
            let shortestIndex = 0;
            let shortestHeight = columnHeights[0];
            for (let i = 1; i < columnCount; i++) {
                if (columnHeights[i] < shortestHeight) {
                    shortestHeight = columnHeights[i];
                    shortestIndex = i;
                }
            }

            // Track position for navigation
            const row = columns[shortestIndex].children.length;
            itemPositions.push({ item, column: shortestIndex, row });

            columns[shortestIndex].appendChild(item);

            // Update height estimate
            const img = item.querySelector('img');
            const itemHeight = img && img.naturalHeight && img.naturalWidth
                ? (img.naturalHeight / img.naturalWidth) * (gallery.clientWidth / columnCount)
                : 300;
            columnHeights[shortestIndex] += itemHeight + 16; // 16 = gap
        });

        // Sort by visual reading order (row first, then column)
        itemPositions.sort((a, b) => {
            if (a.row !== b.row) return a.row - b.row;
            return a.column - b.column;
        });

        // Save navigation order to sessionStorage
        const navOrder = itemPositions.map(p => ({
            type: p.item.dataset.itemType,
            id: p.item.dataset.photoId || p.item.dataset.albumId
        }));
        saveNavigationOrder(navOrder);
    }

    function saveNavigationOrder(order) {
        sessionStorage.setItem('galleryNavOrder', JSON.stringify(order));
    }

    // Rebuild on resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(rebuildMasonry, 100);
    });

    // Initialize masonry
    if (document.readyState === 'complete') {
        initMasonry();
    } else {
        window.addEventListener('load', initMasonry);
    }

    // Load all tags for autocomplete
    async function loadAllTags() {
        try {
            const resp = await fetch('/api/tags/all');
            allTags = await resp.json();
        } catch (e) {
            console.error('Failed to load tags:', e);
        }
    }
    loadAllTags();

    // Restore search from URL on page load
    const urlParams = new URLSearchParams(window.location.search);
    const savedQuery = urlParams.get('q');
    if (savedQuery) {
        searchInput.value = savedQuery;
        sessionStorage.setItem('gallerySearchQuery', savedQuery);
        performSearch();
    } else {
        // Clear sessionStorage if no query in URL
        sessionStorage.removeItem('gallerySearchQuery');
    }

    // Selection handling
    function updateSelectionUI() {
        const count = selectedPhotos.size + selectedAlbums.size;
        if (count > 0) {
            selectionMenu.classList.remove('hidden');
            selectionCount.textContent = count + ' selected';
        } else {
            selectionMenu.classList.add('hidden');
        }

        // Update visual state of items
        document.querySelectorAll('.gallery-item').forEach(item => {
            const photoId = item.dataset.photoId;
            const albumId = item.dataset.albumId;
            if (selectedPhotos.has(photoId) || selectedAlbums.has(albumId)) {
                item.classList.add('selected');
            } else {
                item.classList.remove('selected');
            }
        });
    }

    // Handle click on select indicator
    gallery.addEventListener('click', (e) => {
        const indicator = e.target.closest('.select-indicator');
        if (indicator) {
            e.preventDefault();
            e.stopPropagation();
            const item = indicator.closest('.gallery-item');
            const itemType = item.dataset.itemType;

            if (itemType === 'album') {
                const albumId = item.dataset.albumId;
                if (selectedAlbums.has(albumId)) {
                    selectedAlbums.delete(albumId);
                } else {
                    selectedAlbums.add(albumId);
                }
            } else {
                const photoId = item.dataset.photoId;
                if (selectedPhotos.has(photoId)) {
                    selectedPhotos.delete(photoId);
                } else {
                    selectedPhotos.add(photoId);
                }
            }
            updateSelectionUI();
        }
    });

    // Select all (only visible items)
    document.getElementById('select-all-btn').addEventListener('click', () => {
        allItems.forEach(item => {
            if (item.dataset.hidden !== 'true') {
                if (item.dataset.itemType === 'album') {
                    selectedAlbums.add(item.dataset.albumId);
                } else {
                    selectedPhotos.add(item.dataset.photoId);
                }
            }
        });
        updateSelectionUI();
    });

    // Deselect all
    document.getElementById('deselect-all-btn').addEventListener('click', () => {
        selectedPhotos.clear();
        selectedAlbums.clear();
        updateSelectionUI();
    });

    // Delete selected
    document.getElementById('delete-selected-btn').addEventListener('click', async () => {
        if (selectedPhotos.size === 0 && selectedAlbums.size === 0) return;

        const count = selectedPhotos.size + selectedAlbums.size;
        if (!confirm(`Delete ${count} item(s)? This cannot be undone.`)) return;

        try {
            const resp = await csrfFetch('/api/photos/batch-delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    photo_ids: Array.from(selectedPhotos),
                    album_ids: Array.from(selectedAlbums)
                })
            });
            const data = await resp.json();
            if (data.status === 'ok') {
                location.reload();
            }
        } catch (e) {
            console.error('Delete failed:', e);
            alert('Failed to delete items');
        }
    });

    // AI tags for selected
    document.getElementById('ai-selected-btn').addEventListener('click', async () => {
        if (selectedPhotos.size === 0 && selectedAlbums.size === 0) return;

        const btn = document.getElementById('ai-selected-btn');
        btn.disabled = true;
        btn.textContent = 'Processing...';

        try {
            const resp = await csrfFetch('/api/photos/batch-ai-tags', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    photo_ids: Array.from(selectedPhotos),
                    album_ids: Array.from(selectedAlbums)
                })
            });
            const data = await resp.json();
            if (data.status === 'ok') {
                alert(`AI tags generated for ${data.processed} photo(s)`);
                selectedPhotos.clear();
                selectedAlbums.clear();
                updateSelectionUI();
            }
        } catch (e) {
            console.error('AI tagging failed:', e);
            alert('Failed to generate AI tags');
        } finally {
            btn.disabled = false;
            btn.textContent = 'AI Tags';
        }
    });

    // Tag search with autocomplete
    let debounceTimer;
    searchInput.addEventListener('input', (e) => {
        clearTimeout(debounceTimer);
        const value = e.target.value.trim();

        // Get the last word being typed for suggestions
        const words = value.split(/\s+/);
        const currentWord = words[words.length - 1].toLowerCase();

        // Show suggestions for current word
        if (currentWord.length > 0) {
            debounceTimer = setTimeout(() => {
                const existingWords = words.slice(0, -1).map(w => w.toLowerCase());
                const matches = allTags.filter(t =>
                    t.tag.toLowerCase().includes(currentWord) &&
                    !existingWords.includes(t.tag.toLowerCase())
                ).slice(0, 8);

                if (matches.length > 0) {
                    suggestions.innerHTML = matches.map(t => `
                        <div class="suggestion-item" data-tag="${t.tag}" style="--tag-color: ${t.color}">
                            ${t.tag}
                        </div>
                    `).join('');
                    suggestions.classList.remove('hidden');
                } else {
                    suggestions.classList.add('hidden');
                }
            }, 150);
        } else {
            suggestions.classList.add('hidden');
        }

        // Perform search as user types
        debounceTimer = setTimeout(() => {
            performSearch();
        }, 300);
    });

    // Handle suggestion click - add tag to input
    suggestions.addEventListener('click', (e) => {
        const item = e.target.closest('.suggestion-item');
        if (item) {
            const tag = item.dataset.tag.toLowerCase();
            const value = searchInput.value.trim();
            const words = value.split(/\s+/);
            words[words.length - 1] = tag;
            searchInput.value = words.join(' ') + ' ';
            suggestions.classList.add('hidden');
            searchInput.focus();
            performSearch();
        }
    });

    // Handle Enter key - just perform search
    searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            suggestions.classList.add('hidden');
            performSearch();
        }
    });

    // Hide suggestions on click outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-container')) {
            suggestions.classList.add('hidden');
        }
    });

    // Perform search
    async function performSearch() {
        try {
            const query = searchInput.value.trim();

            // Update URL without reloading
            const url = new URL(window.location);
            if (query) {
                url.searchParams.set('q', query);
                sessionStorage.setItem('gallerySearchQuery', query);
            } else {
                url.searchParams.delete('q');
                sessionStorage.removeItem('gallerySearchQuery');
            }
            window.history.replaceState({}, '', url);

            const resp = await fetch(`/api/photos/search?tags=${encodeURIComponent(query)}`);
            const results = await resp.json();

            // Separate matching IDs by type
            const matchingPhotoIds = new Set(results.filter(r => r.type === 'photo').map(r => r.id));
            const matchingAlbumIds = new Set(results.filter(r => r.type === 'album').map(r => r.id));

            const hasQuery = query.length > 0;

            allItems.forEach(item => {
                const itemType = item.dataset.itemType;
                const photoId = item.dataset.photoId;
                const albumId = item.dataset.albumId;

                let matches = false;
                if (!hasQuery) {
                    matches = true;
                } else if (itemType === 'album') {
                    matches = matchingAlbumIds.has(albumId);
                } else {
                    matches = matchingPhotoIds.has(photoId);
                }

                if (matches) {
                    item.dataset.hidden = 'false';
                } else {
                    item.dataset.hidden = 'true';
                    // Deselect hidden items
                    if (itemType === 'album') {
                        selectedAlbums.delete(albumId);
                    } else {
                        selectedPhotos.delete(photoId);
                    }
                }
            });

            // Rebuild masonry with filtered items
            rebuildMasonry();

            // Update selection UI
            updateSelectionUI();
        } catch (e) {
            console.error('Search failed:', e);
        }
    }
})();

// ============ Lightbox Photo Viewer ============
(function() {
    const lightbox = document.getElementById('lightbox');
    const lightboxMedia = document.getElementById('lightbox-media');
    const lightboxTags = document.getElementById('lightbox-tags');
    const lightboxDates = document.getElementById('lightbox-dates');
    const lightboxDownload = document.getElementById('lightbox-download');
    const lightboxAlbumIndicator = document.getElementById('lightbox-album-indicator');
    const lightboxAlbumBars = document.getElementById('lightbox-album-bars');
    const lightboxAlbumText = document.getElementById('lightbox-album-text');
    const prevBtn = document.querySelector('.lightbox-prev');
    const nextBtn = document.querySelector('.lightbox-next');

    // Navigation state
    let navOrder = []; // [{type, id}, ...]
    let currentNavIndex = -1;
    let currentPhotoId = null;
    let currentAlbumPhotos = []; // Photo IDs in current album
    let currentAlbumIndex = -1;
    let navigationDirection = 0; // -1 = left (prev), 1 = right (next)

    // Expose current photo ID for tag editor
    Object.defineProperty(window, 'currentLightboxPhotoId', {
        get: () => currentPhotoId
    });

    // Reload current photo (called after tag changes)
    window.reloadCurrentPhoto = function() {
        if (currentPhotoId) {
            loadPhoto(currentPhotoId);
        }
    };

    // Load navigation order from sessionStorage
    function loadNavOrder() {
        const stored = sessionStorage.getItem('galleryNavOrder');
        if (stored) {
            try {
                navOrder = JSON.parse(stored);
            } catch (e) {
                navOrder = [];
            }
        }
    }

    // Open photo in lightbox
    window.openPhoto = async function(photoId) {
        loadNavOrder();
        currentPhotoId = photoId;
        currentAlbumPhotos = [];
        currentAlbumIndex = -1;

        // Find position in nav order
        currentNavIndex = navOrder.findIndex(item => item.type === 'photo' && item.id === photoId);

        await loadPhoto(photoId);
        showLightbox();
    };

    // Open album in lightbox (starts from first photo by default)
    window.openAlbum = async function(albumId, startFromEnd = false) {
        loadNavOrder();

        try {
            const resp = await fetch(`/api/albums/${albumId}`);
            if (!resp.ok) return;
            const album = await resp.json();

            if (!album.photos || album.photos.length === 0) return;

            currentAlbumPhotos = album.photos.map(p => p.id);
            currentAlbumIndex = startFromEnd ? currentAlbumPhotos.length - 1 : 0;
            currentPhotoId = currentAlbumPhotos[currentAlbumIndex];

            // Find album position in nav order
            currentNavIndex = navOrder.findIndex(item => item.type === 'album' && item.id === albumId);

            await loadPhoto(currentPhotoId);
            showLightbox();
        } catch (e) {
            console.error('Failed to load album:', e);
        }
    };

    // Load and display photo
    async function loadPhoto(photoId) {
        // Always hide album indicator first, will be shown if photo is in album
        lightboxAlbumIndicator.classList.add('hidden');

        try {
            const resp = await fetch(`/api/photos/${photoId}`);
            if (!resp.ok) {
                console.error('Failed to load photo');
                return;
            }
            const photo = await resp.json();

            // Update media
            if (photo.media_type === 'video') {
                lightboxMedia.innerHTML = `
                    <video src="/uploads/${photo.filename}" controls autoplay loop playsinline class="lightbox-video">
                        Your browser does not support video.
                    </video>`;
            } else {
                lightboxMedia.innerHTML = `
                    <img src="/uploads/${photo.filename}" alt="${photo.original_name}" class="lightbox-image">`;
            }

            // Update tags
            if (photo.tags && photo.tags.length > 0) {
                lightboxTags.innerHTML = photo.tags.map(t =>
                    `<span class="tag" style="--tag-color: ${t.color}">${t.tag}</span>`
                ).join('');
            } else {
                lightboxTags.innerHTML = '<span class="no-tags">No tags</span>';
            }

            // Update dates
            const formatDate = (dateStr) => {
                if (!dateStr) return null;
                const d = new Date(dateStr);
                return d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit', year: 'numeric' }) +
                       ' ' + d.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
            };
            const takenDate = formatDate(photo.taken_at);
            const uploadedDate = formatDate(photo.uploaded_at);
            let datesHtml = '';
            if (takenDate) {
                datesHtml += `<span class="date-item" title="Capture date"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg> ${takenDate}</span>`;
            }
            if (uploadedDate && uploadedDate !== takenDate) {
                datesHtml += `<span class="date-item" title="Upload date"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg> ${uploadedDate}</span>`;
            }
            lightboxDates.innerHTML = datesHtml;

            // Update download link
            lightboxDownload.href = `/uploads/${photo.filename}`;
            lightboxDownload.download = photo.original_name;

            // Update album indicator
            if (photo.album) {
                currentAlbumPhotos = photo.album.photo_ids;
                currentAlbumIndex = photo.album.current - 1;

                lightboxAlbumBars.innerHTML = currentAlbumPhotos.map((id, i) =>
                    `<div class="album-bar ${i === currentAlbumIndex ? 'active' : ''}" data-photo-id="${id}"></div>`
                ).join('');
                lightboxAlbumText.textContent = `${photo.album.current} / ${photo.album.total}`;
                lightboxAlbumIndicator.classList.remove('hidden');

                // Add click handlers to album bars
                lightboxAlbumBars.querySelectorAll('.album-bar').forEach(bar => {
                    bar.addEventListener('click', () => {
                        const targetId = bar.dataset.photoId;
                        currentAlbumIndex = currentAlbumPhotos.indexOf(targetId);
                        currentPhotoId = targetId;
                        loadPhoto(targetId);
                    });
                });

                // Update album editor button visibility
                if (window.setCurrentAlbumInfo) {
                    window.setCurrentAlbumInfo(photo.album.id, photo.album.can_edit);
                }
            } else {
                currentAlbumPhotos = [];
                currentAlbumIndex = -1;
                lightboxAlbumIndicator.classList.add('hidden');

                // Hide album editor button
                if (window.setCurrentAlbumInfo) {
                    window.setCurrentAlbumInfo(null, false);
                }
            }

            // Update URL without reload (preserve folder_id from URL)
            const urlFolderId = new URLSearchParams(window.location.search).get('folder_id') || '';
            history.replaceState(null, '', `?folder_id=${urlFolderId}&photo=${photoId}`);

            updateNavButtons();
        } catch (e) {
            console.error('Error loading photo:', e);
        }
    }

    // Update navigation button visibility
    function updateNavButtons() {
        const hasPrev = canNavigate(-1);
        const hasNext = canNavigate(1);
        prevBtn.style.display = hasPrev ? '' : 'none';
        nextBtn.style.display = hasNext ? '' : 'none';
    }

    // Check if can navigate in direction
    function canNavigate(direction) {
        // If in album, check album bounds
        if (currentAlbumPhotos.length > 0) {
            const newIndex = currentAlbumIndex + direction;
            if (newIndex >= 0 && newIndex < currentAlbumPhotos.length) {
                return true;
            }
        }
        // Check main nav order
        const newNavIndex = currentNavIndex + direction;
        return newNavIndex >= 0 && newNavIndex < navOrder.length;
    }

    // Navigate in direction (-1 = prev, 1 = next)
    window.navigateLightbox = function(direction) {
        navigationDirection = direction;

        // If in album, try to navigate within album first
        if (currentAlbumPhotos.length > 0) {
            const newAlbumIndex = currentAlbumIndex + direction;
            if (newAlbumIndex >= 0 && newAlbumIndex < currentAlbumPhotos.length) {
                currentAlbumIndex = newAlbumIndex;
                currentPhotoId = currentAlbumPhotos[currentAlbumIndex];
                loadPhoto(currentPhotoId);
                return;
            }
            // Exit album, move to next/prev in main nav
            currentAlbumPhotos = [];
            currentAlbumIndex = -1;
        }

        // Navigate in main order
        const newNavIndex = currentNavIndex + direction;
        if (newNavIndex < 0 || newNavIndex >= navOrder.length) return;

        currentNavIndex = newNavIndex;
        const nextItem = navOrder[currentNavIndex];

        if (nextItem.type === 'album') {
            // Entering album from navigation:
            // - Going right (forward): start from first photo
            // - Going left (backward): start from last photo
            const startFromEnd = direction < 0;
            openAlbum(nextItem.id, startFromEnd);
        } else {
            currentPhotoId = nextItem.id;
            loadPhoto(currentPhotoId);
        }
    };

    // Show lightbox
    function showLightbox() {
        lightbox.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
    }

    // Close lightbox
    window.closeLightbox = function() {
        lightbox.classList.add('hidden');
        document.body.style.overflow = '';

        // Stop video if playing
        const video = lightboxMedia.querySelector('video');
        if (video) video.pause();

        // Restore URL
        const url = new URL(window.location);
        url.searchParams.delete('photo');
        history.replaceState(null, '', url);
    };

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
        if (lightbox.classList.contains('hidden')) return;
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        switch (e.key) {
            case 'ArrowLeft':
                e.preventDefault();
                navigateLightbox(-1);
                break;
            case 'ArrowRight':
                e.preventDefault();
                navigateLightbox(1);
                break;
            case 'Escape':
                e.preventDefault();
                closeLightbox();
                break;
        }
    });

    // Touch/swipe navigation for mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    let isSwiping = false;
    const minSwipeDistance = 50;
    const minVerticalSwipeDistance = 80;

    lightbox.addEventListener('touchstart', (e) => {
        // Ignore if touching controls or panels
        if (e.target.closest('.lightbox-info') ||
            e.target.closest('.tag-editor-panel') ||
            e.target.closest('.album-editor-panel') ||
            e.target.closest('.lightbox-nav') ||
            e.target.closest('.lightbox-close') ||
            e.target.closest('.add-photos-modal')) {
            return;
        }
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
        isSwiping = true;
    }, { passive: true });

    lightbox.addEventListener('touchend', (e) => {
        if (!isSwiping) return;
        isSwiping = false;

        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        handleSwipe();
    }, { passive: true });

    function handleSwipe() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const absDeltaX = Math.abs(deltaX);
        const absDeltaY = Math.abs(deltaY);

        // Determine if horizontal or vertical swipe
        if (absDeltaY > absDeltaX && absDeltaY >= minVerticalSwipeDistance) {
            // Vertical swipe - close lightbox
            const direction = deltaY > 0 ? 'down' : 'up';
            closeLightboxWithAnimation(direction);
        } else if (absDeltaX >= minSwipeDistance && absDeltaX > absDeltaY) {
            // Horizontal swipe - navigate
            if (deltaX > 0) {
                navigateLightboxAnimated(-1);
            } else {
                navigateLightboxAnimated(1);
            }
        }
    }

    // Navigate with slide animation
    function navigateLightboxAnimated(direction) {
        if (!canNavigate(direction)) return;

        const slideOutClass = direction > 0 ? 'slide-out-left' : 'slide-out-right';
        const slideInClass = direction > 0 ? 'slide-in-left' : 'slide-in-right';

        // Slide out current
        lightboxMedia.classList.add(slideOutClass);

        setTimeout(() => {
            lightboxMedia.classList.remove(slideOutClass);
            // Navigate and slide in new
            navigateLightbox(direction);
            lightboxMedia.classList.add(slideInClass);

            setTimeout(() => {
                lightboxMedia.classList.remove(slideInClass);
            }, 250);
        }, 200);
    }

    // Close with vertical slide animation
    function closeLightboxWithAnimation(direction) {
        const slideClass = direction === 'up' ? 'slide-out-up' : 'slide-out-down';
        lightboxMedia.classList.add(slideClass);

        setTimeout(() => {
            lightboxMedia.classList.remove(slideClass);
            closeLightbox();
        }, 200);
    }

    // Check URL for photo param on load
    const urlParams = new URLSearchParams(window.location.search);
    const photoParam = urlParams.get('photo');
    if (photoParam) {
        openPhoto(photoParam);
    }
})();

// ============ Tag Editor ============
(function() {
    const tagEditorPanel = document.getElementById('tag-editor-panel');
    const lightbox = document.getElementById('lightbox');
    const tagSearch = document.getElementById('tag-search');
    const addNewTagSection = document.getElementById('add-new-tag-section');
    const presetsContainer = document.getElementById('tag-presets-container');
    const currentTagsContainer = document.getElementById('current-tags-container');

    let categories = [];
    let editingTags = [];
    let originalTags = [];
    let selectedCategoryId = null;
    let currentEditingPhotoId = null;

    // Open tag editor
    window.openTagEditor = async function() {
        if (!window.currentLightboxPhotoId) return;

        currentEditingPhotoId = window.currentLightboxPhotoId;

        // Get current tags from lightbox
        const resp = await fetch(`/api/photos/${currentEditingPhotoId}`);
        const photo = await resp.json();

        originalTags = photo.tags.map(t => ({
            id: t.id,
            name: t.tag,
            category_id: t.category_id,
            color: t.color
        }));
        editingTags = originalTags.map(t => ({ ...t }));

        updateCurrentTagsDisplay();
        tagEditorPanel.classList.add('open');
        lightbox.classList.add('panel-open');
        await loadCategories();
        await loadTagPresets();
        tagSearch.value = '';
        tagSearch.focus();
        addNewTagSection.classList.add('hidden');
    };

    // Close tag editor
    window.closeTagEditor = function() {
        tagEditorPanel.classList.remove('open');
        lightbox.classList.remove('panel-open');
        selectedCategoryId = null;
        editingTags = [];
        originalTags = [];
    };

    // Load tag categories
    async function loadCategories() {
        const response = await fetch('/api/tag-categories');
        categories = await response.json();
        renderCategoryButtons();
    }

    // Load tag presets
    async function loadTagPresets(search = "") {
        const response = await fetch(`/api/tag-presets?search=${encodeURIComponent(search)}`);
        const data = await response.json();
        renderPresets(data);
        return data;
    }

    // Render preset tags by category
    function renderPresets(presetsData) {
        if (presetsData.length === 0) {
            presetsContainer.innerHTML = '<p class="no-presets">No matching tags found</p>';
            return;
        }

        presetsContainer.innerHTML = presetsData.map(category => `
            <div class="preset-category">
                <h4 style="--cat-color: ${category.color}">${category.name}</h4>
                <div class="preset-tags">
                    ${category.tags.map(tag => {
                        const isSelected = editingTags.some(t => t.name.toLowerCase() === tag.name.toLowerCase());
                        return `
                            <button class="preset-tag ${isSelected ? 'selected' : ''}"
                                    style="--tag-color: ${category.color}"
                                    data-tag-name="${tag.name}"
                                    data-category-id="${category.id}"
                                    data-color="${category.color}">
                                ${tag.name}
                            </button>
                        `;
                    }).join('')}
                </div>
            </div>
        `).join('');

        // Add click handlers
        presetsContainer.querySelectorAll('.preset-tag').forEach(btn => {
            btn.onclick = () => toggleTag(btn.dataset.tagName, parseInt(btn.dataset.categoryId), btn.dataset.color);
        });
    }

    // Render category buttons for new tags
    function renderCategoryButtons() {
        const container = document.getElementById('category-buttons');
        container.innerHTML = categories.map(cat => `
            <button class="category-btn" style="--cat-color: ${cat.color}" data-category-id="${cat.id}">
                ${cat.name}
            </button>
        `).join('');

        container.querySelectorAll('.category-btn').forEach(btn => {
            btn.onclick = () => selectCategory(parseInt(btn.dataset.categoryId));
        });
    }

    // Select category for new tag
    function selectCategory(categoryId) {
        selectedCategoryId = categoryId;
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.classList.toggle('selected', parseInt(btn.dataset.categoryId) === categoryId);
        });
        document.getElementById('add-new-tag-btn').disabled = false;
    }

    // Toggle tag selection
    function toggleTag(tagName, categoryId, color) {
        const index = editingTags.findIndex(t => t.name.toLowerCase() === tagName.toLowerCase());

        if (index === -1) {
            editingTags.push({ name: tagName, category_id: categoryId, color: color });
        } else {
            editingTags.splice(index, 1);
        }

        updateCurrentTagsDisplay();
        updatePresetButtons();
    }

    // Remove tag from editing list
    window.removeTagFromEditing = function(tagName) {
        const index = editingTags.findIndex(t => t.name.toLowerCase() === tagName.toLowerCase());
        if (index !== -1) {
            editingTags.splice(index, 1);
            updateCurrentTagsDisplay();
            updatePresetButtons();
        }
    };

    // Update current tags display
    function updateCurrentTagsDisplay() {
        if (editingTags.length === 0) {
            currentTagsContainer.innerHTML = '<span class="no-tags-hint">No tags selected</span>';
        } else {
            currentTagsContainer.innerHTML = editingTags.map(tag => `
                <span class="selected-tag" style="--tag-color: ${tag.color}">
                    ${tag.name}
                    <button class="tag-remove" onclick="removeTagFromEditing('${tag.name}')">&times;</button>
                </span>
            `).join('');
        }
    }

    // Update preset button states
    function updatePresetButtons() {
        presetsContainer.querySelectorAll('.preset-tag').forEach(btn => {
            const tagName = btn.dataset.tagName;
            const isSelected = editingTags.some(t => t.name.toLowerCase() === tagName.toLowerCase());
            btn.classList.toggle('selected', isSelected);
        });
    }

    // Save tag changes
    window.saveTagChanges = async function() {
        const saveBtn = document.getElementById('save-tags-btn');
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';

        const toAdd = editingTags.filter(et =>
            !originalTags.some(ot => ot.name.toLowerCase() === et.name.toLowerCase())
        );

        const toRemove = originalTags.filter(ot =>
            !editingTags.some(et => et.name.toLowerCase() === ot.name.toLowerCase())
        );

        for (const tag of toRemove) {
            await csrfFetch(`/api/photos/${currentEditingPhotoId}/tag/${tag.id}`, { method: 'DELETE' });
        }

        for (const tag of toAdd) {
            await csrfFetch(`/api/photos/${currentEditingPhotoId}/tag`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tag: tag.name, category_id: tag.category_id })
            });
        }

        saveBtn.disabled = false;
        saveBtn.textContent = 'Save Changes';
        closeTagEditor();

        // Reload photo in lightbox to show updated tags
        if (window.reloadCurrentPhoto) {
            window.reloadCurrentPhoto();
        }
    };

    // Add new tag to library
    window.addNewTag = async function() {
        const tagName = tagSearch.value.trim();
        if (!tagName || !selectedCategoryId) return;

        if (editingTags.some(t => t.name.toLowerCase() === tagName.toLowerCase())) {
            alert('This tag is already selected');
            return;
        }

        await csrfFetch('/api/tag-presets', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: tagName, category_id: selectedCategoryId })
        });

        const category = categories.find(c => c.id === selectedCategoryId);
        editingTags.push({
            name: tagName.toLowerCase(),
            category_id: selectedCategoryId,
            color: category?.color || '#6b7280'
        });

        updateCurrentTagsDisplay();
        tagSearch.value = '';
        addNewTagSection.classList.add('hidden');
        await loadTagPresets();
    };

    // Request AI analysis
    window.requestAIAnalysis = async function() {
        if (!currentEditingPhotoId) return;

        const btn = document.getElementById('request-ai-btn');
        btn.disabled = true;
        btn.innerHTML = 'Analyzing...';

        try {
            const response = await csrfFetch(`/api/photos/${currentEditingPhotoId}/ai-tags`, {
                method: 'POST'
            });
            const data = await response.json();

            if (data.status === 'ok') {
                closeTagEditor();
                if (window.reloadCurrentPhoto) {
                    window.reloadCurrentPhoto();
                }
            } else {
                btn.innerHTML = 'Error occurred';
                setTimeout(() => {
                    btn.disabled = false;
                    btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <path d="M12 2a4 4 0 0 1 4 4v2a4 4 0 0 1-8 0V6a4 4 0 0 1 4-4z"/>
                        <path d="M16 14v1a4 4 0 0 1-8 0v-1"/><circle cx="12" cy="20" r="2"/><path d="M12 18v-2"/>
                    </svg> Request AI Analysis`;
                }, 2000);
            }
        } catch (err) {
            btn.innerHTML = 'Error occurred';
            btn.disabled = false;
        }
    };

    // Search functionality
    let searchTimeout;
    tagSearch.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        const query = tagSearch.value.trim();

        searchTimeout = setTimeout(async () => {
            const presets = await loadTagPresets(query);

            if (query.length > 0) {
                const hasExactMatch = presets.some(cat =>
                    cat.tags.some(t => t.name.toLowerCase() === query.toLowerCase())
                );

                if (!hasExactMatch) {
                    document.getElementById('new-tag-name').textContent = query;
                    addNewTagSection.classList.remove('hidden');
                    selectedCategoryId = null;
                    document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('selected'));
                    document.getElementById('add-new-tag-btn').disabled = true;
                } else {
                    addNewTagSection.classList.add('hidden');
                }
            } else {
                addNewTagSection.classList.add('hidden');
            }
        }, 300);
    });

    // Handle ESC key in tag editor
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && tagEditorPanel.classList.contains('open')) {
            e.preventDefault();
            e.stopPropagation();
            closeTagEditor();
        }
    });
})();

// ============ Album Editor ============
(function() {
    const albumEditorPanel = document.getElementById('album-editor-panel');
    const lightbox = document.getElementById('lightbox');
    const editAlbumBtn = document.getElementById('lightbox-edit-album');
    const albumCoverGrid = document.getElementById('album-cover-grid');
    const albumPhotosList = document.getElementById('album-photos-list');
    const albumPhotoCount = document.getElementById('album-photo-count');

    // Add photos modal elements
    const addPhotosModal = document.getElementById('add-photos-modal');
    const availablePhotosGrid = document.getElementById('available-photos-grid');
    const selectedPhotosCount = document.getElementById('selected-photos-count');
    const confirmAddBtn = document.getElementById('confirm-add-btn');
    const openAddPhotosBtn = document.getElementById('open-add-photos-btn');

    // Album editor state
    let currentAlbumId = null;
    let albumPhotos = []; // Current photos in order
    let coverPhotoId = null;
    let availablePhotos = [];
    let selectedToAdd = new Set();
    let canEdit = false;
    let hasChanges = false;

    // Drag state
    let draggedItem = null;
    let draggedIndex = -1;

    // Expose album info for lightbox
    window.setCurrentAlbumInfo = function(albumId, canEditAlbum) {
        currentAlbumId = albumId;
        canEdit = canEditAlbum;
        if (albumId && canEditAlbum) {
            editAlbumBtn.classList.remove('hidden');
        } else {
            editAlbumBtn.classList.add('hidden');
        }
    };

    // Open album editor
    window.openAlbumEditor = async function() {
        if (!currentAlbumId || !canEdit) return;

        try {
            // Load album data
            const albumResp = await fetch(`/api/albums/${currentAlbumId}`);
            const album = await albumResp.json();

            albumPhotos = album.photos.map(p => ({
                id: p.id,
                filename: p.filename,
                media_type: p.media_type
            }));
            coverPhotoId = album.cover_photo_id || album.effective_cover_photo_id;

            // Load available photos
            const availResp = await fetch(`/api/albums/${currentAlbumId}/available-photos`);
            const availData = await availResp.json();
            availablePhotos = availData.photos || [];
            selectedToAdd.clear();
            hasChanges = false;

            renderCoverGrid();
            renderPhotosList();
            updateOpenAddPhotosBtn();

            albumEditorPanel.classList.add('open');
            lightbox.classList.add('panel-open');
        } catch (e) {
            console.error('Failed to load album:', e);
        }
    };

    // Close album editor
    window.closeAlbumEditor = function() {
        albumEditorPanel.classList.remove('open');
        lightbox.classList.remove('panel-open');

        // Reload page if changes were made to refresh gallery
        if (hasChanges) {
            window.location.reload();
            return;
        }

        currentAlbumId = null;
        albumPhotos = [];
        coverPhotoId = null;
        availablePhotos = [];
        selectedToAdd.clear();
        hasChanges = false;
    };

    // Update add photos button state
    function updateOpenAddPhotosBtn() {
        if (availablePhotos.length === 0) {
            openAddPhotosBtn.disabled = true;
            openAddPhotosBtn.textContent = 'No photos to add';
        } else {
            openAddPhotosBtn.disabled = false;
            openAddPhotosBtn.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                Add Photos (${availablePhotos.length} available)
            `;
        }
    }

    // Render cover photo grid
    function renderCoverGrid() {
        if (albumPhotos.length === 0) {
            albumCoverGrid.innerHTML = '<div class="empty-state">No photos</div>';
            return;
        }

        albumCoverGrid.innerHTML = albumPhotos.map(photo => `
            <div class="album-cover-option ${photo.id === coverPhotoId ? 'selected' : ''}"
                 data-photo-id="${photo.id}"
                 onclick="selectCoverPhoto('${photo.id}')">
                <img src="/thumbnails/${photo.id}.jpg" alt="">
            </div>
        `).join('');
    }

    // Select cover photo
    window.selectCoverPhoto = async function(photoId) {
        if (photoId === coverPhotoId) return;

        try {
            const resp = await csrfFetch(`/api/albums/${currentAlbumId}/cover`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ photo_id: photoId })
            });

            if (resp.ok) {
                coverPhotoId = photoId;
                hasChanges = true;
                renderCoverGrid();
            }
        } catch (e) {
            console.error('Failed to set cover:', e);
        }
    };

    // Render photos list (sortable)
    function renderPhotosList() {
        albumPhotoCount.textContent = `(${albumPhotos.length})`;

        if (albumPhotos.length === 0) {
            albumPhotosList.innerHTML = '<div class="empty-state">No photos in album</div>';
            return;
        }

        albumPhotosList.innerHTML = albumPhotos.map((photo, index) => `
            <div class="album-photo-item" data-photo-id="${photo.id}" data-index="${index}" draggable="true">
                <div class="drag-handle">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="8" y1="6" x2="16" y2="6"/>
                        <line x1="8" y1="12" x2="16" y2="12"/>
                        <line x1="8" y1="18" x2="16" y2="18"/>
                    </svg>
                </div>
                <img class="photo-thumb" src="/thumbnails/${photo.id}.jpg" alt="">
                <span class="photo-info">${index + 1}</span>
                <button class="remove-btn" onclick="removePhotoFromAlbum('${photo.id}')" title="Remove from album">&times;</button>
            </div>
        `).join('');

        setupDragDrop();
    }

    // Setup drag and drop
    function setupDragDrop() {
        const items = albumPhotosList.querySelectorAll('.album-photo-item');

        items.forEach((item, index) => {
            item.addEventListener('dragstart', (e) => {
                draggedItem = item;
                draggedIndex = index;
                item.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                items.forEach(i => i.classList.remove('drag-over'));
                draggedItem = null;
                draggedIndex = -1;
            });

            item.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (draggedItem && draggedItem !== item) {
                    item.classList.add('drag-over');
                }
            });

            item.addEventListener('dragleave', () => {
                item.classList.remove('drag-over');
            });

            item.addEventListener('drop', async (e) => {
                e.preventDefault();
                item.classList.remove('drag-over');

                if (!draggedItem || draggedItem === item) return;

                const targetIndex = parseInt(item.dataset.index);

                // Reorder array
                const [moved] = albumPhotos.splice(draggedIndex, 1);
                albumPhotos.splice(targetIndex, 0, moved);

                // Save new order to server
                const photoIds = albumPhotos.map(p => p.id);
                try {
                    await csrfFetch(`/api/albums/${currentAlbumId}/reorder`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ photo_ids: photoIds })
                    });
                    hasChanges = true;
                } catch (e) {
                    console.error('Failed to reorder:', e);
                }

                renderPhotosList();
                renderCoverGrid();
            });
        });
    }

    // Remove photo from album
    window.removePhotoFromAlbum = async function(photoId) {
        try {
            const resp = await csrfFetch(`/api/albums/${currentAlbumId}/photos`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ photo_ids: [photoId] })
            });

            if (resp.ok) {
                hasChanges = true;

                // Remove from local state
                albumPhotos = albumPhotos.filter(p => p.id !== photoId);

                // Add to available photos
                availablePhotos.unshift({ id: photoId });

                // Reset cover if removed
                if (coverPhotoId === photoId) {
                    coverPhotoId = albumPhotos.length > 0 ? albumPhotos[0].id : null;
                }

                renderPhotosList();
                renderCoverGrid();
                updateOpenAddPhotosBtn();
            }
        } catch (e) {
            console.error('Failed to remove photo:', e);
        }
    };

    // ========== Add Photos Modal ==========

    // Open add photos modal
    window.openAddPhotosModal = function() {
        if (availablePhotos.length === 0) return;

        selectedToAdd.clear();
        renderAvailablePhotosGrid();
        addPhotosModal.classList.remove('hidden');
    };

    // Close add photos modal
    window.closeAddPhotosModal = function() {
        addPhotosModal.classList.add('hidden');
        selectedToAdd.clear();
    };

    // Render available photos grid
    function renderAvailablePhotosGrid() {
        if (availablePhotos.length === 0) {
            availablePhotosGrid.innerHTML = '<div class="empty-state">No photos available</div>';
            return;
        }

        availablePhotosGrid.innerHTML = availablePhotos.map(p => `
            <div class="available-photo-item ${selectedToAdd.has(p.id) ? 'selected' : ''}"
                 data-photo-id="${p.id}"
                 onclick="togglePhotoSelection('${p.id}')">
                <img src="/thumbnails/${p.id}.jpg" alt="">
                <div class="photo-check-indicator">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </div>
            </div>
        `).join('');

        updateSelectionUI();
    }

    // Toggle photo selection
    window.togglePhotoSelection = function(photoId) {
        if (selectedToAdd.has(photoId)) {
            selectedToAdd.delete(photoId);
        } else {
            selectedToAdd.add(photoId);
        }

        // Update visual state
        const item = availablePhotosGrid.querySelector(`[data-photo-id="${photoId}"]`);
        if (item) {
            item.classList.toggle('selected', selectedToAdd.has(photoId));
        }

        updateSelectionUI();
    };

    // Update selection count and button
    function updateSelectionUI() {
        selectedPhotosCount.textContent = selectedToAdd.size > 0
            ? `${selectedToAdd.size} selected`
            : 'None selected';

        confirmAddBtn.disabled = selectedToAdd.size === 0;
        confirmAddBtn.textContent = selectedToAdd.size > 0
            ? `Add ${selectedToAdd.size} Photo${selectedToAdd.size > 1 ? 's' : ''}`
            : 'Add Selected';
    }

    // Confirm adding selected photos
    window.confirmAddPhotos = async function() {
        if (selectedToAdd.size === 0) return;

        const photoIds = Array.from(selectedToAdd);

        try {
            const resp = await csrfFetch(`/api/albums/${currentAlbumId}/photos`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ photo_ids: photoIds })
            });

            if (resp.ok) {
                hasChanges = true;

                // Add to album photos
                for (const id of photoIds) {
                    const photo = availablePhotos.find(p => p.id === id);
                    if (photo) {
                        albumPhotos.push({ id: photo.id, filename: photo.filename || `${photo.id}.jpg` });
                    }
                }

                // Remove from available
                availablePhotos = availablePhotos.filter(p => !selectedToAdd.has(p.id));
                selectedToAdd.clear();

                // Close modal and update editor
                closeAddPhotosModal();
                renderPhotosList();
                renderCoverGrid();
                updateOpenAddPhotosBtn();
            }
        } catch (e) {
            console.error('Failed to add photos:', e);
        }
    };

    // Keyboard: ESC to close modal
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !addPhotosModal.classList.contains('hidden')) {
            e.preventDefault();
            closeAddPhotosModal();
        }
    });

    // Handle ESC key in album editor
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && albumEditorPanel.classList.contains('open') && addPhotosModal.classList.contains('hidden')) {
            e.preventDefault();
            e.stopPropagation();
            closeAlbumEditor();
        }
    });
})();
</script>
{% endblock %}
