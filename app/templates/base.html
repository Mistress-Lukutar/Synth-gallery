<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <title>{% block title %}Synth{% endblock %}</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="app-layout">
        <!-- Sidebar -->
        <aside id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>Folders</h3>
                <button id="create-folder-btn" class="btn btn-small" title="Create folder">+</button>
            </div>
            <div class="folder-tree" id="folder-tree">
                <!-- Folder tree rendered by JS -->
            </div>
        </aside>

        <!-- Main content area -->
        <div class="main-content">
            <header>
                <nav>
                    <button id="sidebar-toggle" class="sidebar-toggle" title="Toggle folders">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12h18M3 6h18M3 18h18"/>
                        </svg>
                    </button>

                    <a href="/" class="logo"><img src="/static/favicon.svg" alt="" class="logo-icon">Synth</a>

                    {% block header_controls %}
                    <!-- Tag Search -->
                    <div class="search-container">
                        <input type="text" id="tag-search-input" placeholder="Search by tags..." autocomplete="off">
                        <div id="tag-suggestions" class="suggestions hidden"></div>
                    </div>

                    <!-- Sort Selector -->
                    <div class="sort-container">
                        <select id="sort-select" class="sort-select" title="Sort photos by">
                            <option value="uploaded" {% if sort == 'uploaded' %}selected{% endif %}>Upload date</option>
                            <option value="taken" {% if sort == 'taken' %}selected{% endif %}>Capture date</option>
                        </select>
                    </div>

                    <!-- Selection Menu (hidden by default) -->
                    <div id="selection-menu" class="selection-menu hidden">
                        <span id="selection-count">0 selected</span>
                        <button id="select-all-btn" class="btn btn-small btn-secondary">Select All</button>
                        <button id="deselect-all-btn" class="btn btn-small btn-secondary">Deselect</button>
                        <button id="ai-selected-btn" class="btn btn-small">AI Tags</button>
                        <button id="delete-selected-btn" class="btn btn-small btn-danger">Delete</button>
                    </div>
                    {% endblock %}

                    <button id="upload-btn" class="btn">Upload</button>

                    {% if user %}
                    <div class="user-menu">
                        <span class="user-name">{{ user.display_name }}</span>
                        <a href="/logout" class="btn btn-secondary btn-small">Logout</a>
                    </div>
                    {% endif %}
                </nav>
            </header>

            <main>
                {% block content %}{% endblock %}
            </main>
        </div>
    </div>

    <!-- Sidebar overlay for mobile -->
    <div id="sidebar-overlay" class="sidebar-overlay hidden"></div>

    <!-- Upload modal -->
    <div id="upload-modal" class="modal hidden">
        <div class="modal-content upload-modal-content">
            <span class="close">&times;</span>
            <h2>Upload Media</h2>

            <div class="upload-mode-tabs">
                <button type="button" class="upload-tab active" data-mode="files">Files</button>
                <button type="button" class="upload-tab" data-mode="folder">Folder</button>
            </div>

            <div id="drop-zone" class="drop-zone">
                <input type="file" id="file-input" accept="image/*,video/mp4,video/webm" multiple style="display:none">
                <input type="file" id="folder-input" webkitdirectory multiple style="display:none">
                <div class="drop-zone-text" id="files-drop-text">
                    <span class="drop-icon">+</span>
                    <p>Drag & drop images or videos here</p>
                    <p class="drop-hint">or click to select files (jpg, png, gif, webp, mp4, webm)</p>
                </div>
                <div class="drop-zone-text hidden" id="folder-drop-text">
                    <span class="drop-icon">üìÅ</span>
                    <p>Click to select a folder</p>
                    <p class="drop-hint">Root files ‚Üí photos, subfolders ‚Üí albums</p>
                </div>
            </div>

            <div id="upload-preview-container" class="upload-preview-container hidden">
                <div class="preview-header">
                    <span id="preview-count">0 files selected</span>
                    <button type="button" id="clear-files-btn" class="btn btn-small btn-secondary">Clear</button>
                </div>
                <div id="upload-preview" class="upload-preview"></div>
            </div>

            <div id="upload-options" class="upload-options hidden">
                <div class="upload-option">
                    <label class="checkbox-label">
                        <input type="checkbox" id="upload-as-album">
                        <span class="checkmark"></span>
                        Upload as album
                    </label>
                </div>

                <div class="upload-option">
                    <label class="checkbox-label">
                        <input type="checkbox" id="auto-ai-tags">
                        <span class="checkmark"></span>
                        Auto-generate AI tags
                    </label>
                </div>

                <div id="manual-tags-section" class="manual-tags-section">
                    <label>Add tags:</label>
                    <input type="text" id="upload-tags-input" placeholder="tag1, tag2, tag3..." autocomplete="off">
                    <p class="input-hint">Comma-separated tags to apply to all photos</p>
                </div>
            </div>

            <div id="upload-progress" class="upload-progress hidden">
                <div class="progress-bar"><div id="progress-fill" class="progress-fill"></div></div>
                <span id="progress-text" class="progress-text">Uploading...</span>
            </div>

            <div id="upload-actions" class="upload-actions">
                <button type="button" id="cancel-upload-btn" class="btn btn-secondary">Cancel</button>
                <button type="button" id="submit-upload-btn" class="btn" disabled>Upload</button>
            </div>
        </div>
    </div>

    <!-- Folder modal -->
    <div id="folder-modal" class="modal hidden">
        <div class="modal-content folder-modal-content">
            <span class="close">&times;</span>
            <h2 id="folder-modal-title">Create Folder</h2>

            <div class="form-group">
                <label for="folder-name-input">Folder name:</label>
                <input type="text" id="folder-name-input" placeholder="My Folder" autocomplete="off">
            </div>

            <div class="form-group">
                <label for="folder-parent-select">Parent folder:</label>
                <select id="folder-parent-select">
                    <option value="">Root level</option>
                </select>
            </div>

            <div class="modal-actions">
                <button type="button" id="folder-cancel-btn" class="btn btn-secondary">Cancel</button>
                <button type="button" id="folder-submit-btn" class="btn">Create</button>
            </div>
        </div>
    </div>

    <!-- Share modal -->
    <div id="share-modal" class="modal hidden">
        <div class="modal-content share-modal-content">
            <span class="close" onclick="closeShareModal()">&times;</span>
            <h2>Share Folder</h2>

            <!-- User search -->
            <div class="share-search">
                <input type="text" id="user-search-input" placeholder="Search users..." autocomplete="off">
                <div id="user-search-results" class="user-search-results hidden"></div>
            </div>

            <!-- Add permission form -->
            <div id="add-permission-form" class="add-permission-form hidden">
                <span id="selected-user-name"></span>
                <select id="permission-level-select">
                    <option value="viewer">Viewer (view only)</option>
                    <option value="editor">Editor (can upload)</option>
                </select>
                <button type="button" id="add-permission-btn" class="btn">Add</button>
                <button type="button" id="cancel-add-btn" class="btn btn-secondary">Cancel</button>
            </div>

            <!-- Current permissions list -->
            <div class="permissions-section">
                <h3>People with access</h3>
                <div id="permissions-list" class="permissions-list">
                    <!-- Dynamically populated -->
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" onclick="closeShareModal()" class="btn">Done</button>
            </div>
        </div>
    </div>

    <script>
        // CSRF protection helper
        function getCsrfToken() {
            // First try meta tag
            const meta = document.querySelector('meta[name="csrf-token"]');
            if (meta) return meta.getAttribute('content');
            // Fallback to cookie
            const match = document.cookie.match(/synth_csrf=([^;]+)/);
            return match ? match[1] : '';
        }

        // Enhanced fetch with CSRF token
        async function csrfFetch(url, options = {}) {
            const csrfToken = getCsrfToken();
            const headers = options.headers || {};

            // Add CSRF header for mutating requests
            if (['POST', 'PUT', 'DELETE', 'PATCH'].includes((options.method || 'GET').toUpperCase())) {
                headers['X-CSRF-Token'] = csrfToken;
            }

            return fetch(url, { ...options, headers });
        }

        // Get current folder ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        const currentFolderId = urlParams.get('folder_id');
        console.log('[DEBUG] Current folder ID:', currentFolderId);
    </script>

    <script>
        // Upload modal elements
        const modal = document.getElementById('upload-modal');
        const uploadBtn = document.getElementById('upload-btn');
        const closeBtn = modal.querySelector('.close');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const folderInput = document.getElementById('folder-input');
        const filesDropText = document.getElementById('files-drop-text');
        const folderDropText = document.getElementById('folder-drop-text');
        const previewContainer = document.getElementById('upload-preview-container');
        const preview = document.getElementById('upload-preview');
        const previewCount = document.getElementById('preview-count');
        const clearFilesBtn = document.getElementById('clear-files-btn');
        const uploadOptions = document.getElementById('upload-options');
        const albumCheckbox = document.getElementById('upload-as-album');
        const autoAiTagsCheckbox = document.getElementById('auto-ai-tags');
        const tagsInput = document.getElementById('upload-tags-input');
        const progressDiv = document.getElementById('upload-progress');
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        const cancelBtn = document.getElementById('cancel-upload-btn');
        const submitBtn = document.getElementById('submit-upload-btn');

        let isUploading = false;
        let uploadMode = 'files'; // 'files' or 'folder'
        let folderFiles = []; // Store files with their relative paths for folder mode

        // Open/close modal
        uploadBtn.onclick = () => modal.classList.remove('hidden');
        closeBtn.onclick = () => closeModal();
        cancelBtn.onclick = () => closeModal();
        modal.onclick = (e) => {
            if (e.target === modal && !isUploading) closeModal();
        };

        function closeModal() {
            if (isUploading) return;
            modal.classList.add('hidden');
            resetUploadForm();
        }

        function resetUploadForm() {
            fileInput.value = '';
            folderInput.value = '';
            folderFiles = [];
            preview.innerHTML = '';
            previewContainer.classList.add('hidden');
            uploadOptions.classList.add('hidden');
            progressDiv.classList.add('hidden');
            albumCheckbox.checked = false;
            autoAiTagsCheckbox.checked = false;
            tagsInput.value = '';
            submitBtn.disabled = true;
            progressFill.style.width = '0%';
            // Reset to files mode
            setUploadMode('files');
        }

        // Upload mode tabs
        document.querySelectorAll('.upload-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const mode = tab.dataset.mode;
                setUploadMode(mode);
            });
        });

        function setUploadMode(mode) {
            uploadMode = mode;
            document.querySelectorAll('.upload-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.mode === mode);
            });

            if (mode === 'folder') {
                filesDropText.classList.add('hidden');
                folderDropText.classList.remove('hidden');
                // Hide album option in folder mode (structure determines albums)
                albumCheckbox.closest('.upload-option').style.display = 'none';
            } else {
                filesDropText.classList.remove('hidden');
                folderDropText.classList.add('hidden');
                // Show album option in files mode
                albumCheckbox.closest('.upload-option').style.display = '';
            }

            // Clear current selection when switching modes
            fileInput.value = '';
            folderInput.value = '';
            folderFiles = [];
            preview.innerHTML = '';
            previewContainer.classList.add('hidden');
            uploadOptions.classList.add('hidden');
            submitBtn.disabled = true;
        }

        // Handle click on drop zone
        dropZone.onclick = (e) => {
            if (e.target.tagName === 'INPUT') return;
            if (uploadMode === 'folder') {
                folderInput.click();
            } else {
                fileInput.click();
            }
        };

        // Check if file is valid media (image or video)
        function isValidMedia(file) {
            return file.type.startsWith('image/') ||
                   file.type === 'video/mp4' ||
                   file.type === 'video/webm';
        }

        // Update preview when files selected
        function updatePreview(files) {
            const mediaFiles = Array.from(files).filter(isValidMedia);

            if (mediaFiles.length === 0) {
                previewContainer.classList.add('hidden');
                uploadOptions.classList.add('hidden');
                submitBtn.disabled = true;
                return;
            }

            preview.innerHTML = '';
            for (const file of mediaFiles) {
                if (file.type.startsWith('video/')) {
                    // Create video thumbnail preview
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(file);
                    video.className = 'preview-thumb';
                    video.title = file.name;
                    video.muted = true;
                    video.preload = 'metadata';
                    preview.appendChild(video);
                } else {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.className = 'preview-thumb';
                    img.title = file.name;
                    preview.appendChild(img);
                }
            }

            previewCount.textContent = `${mediaFiles.length} file${mediaFiles.length > 1 ? 's' : ''} selected`;
            previewContainer.classList.remove('hidden');
            uploadOptions.classList.remove('hidden');
            submitBtn.disabled = false;

            // Show album option only for multiple files
            const albumOption = albumCheckbox.closest('.upload-option');
            if (mediaFiles.length > 1) {
                albumOption.style.display = '';
            } else {
                albumOption.style.display = 'none';
                albumCheckbox.checked = false;
            }
        }

        fileInput.onchange = () => updatePreview(fileInput.files);

        // Folder input handler
        folderInput.onchange = () => {
            const files = Array.from(folderInput.files);
            processFolderFiles(files);
        };

        function processFolderFiles(files) {
            // Filter and group files by relative path
            folderFiles = [];
            const groups = { '__root__': [] };

            files.forEach(file => {
                if (!isValidMedia(file)) return;

                const path = file.webkitRelativePath;
                const parts = path.split('/');
                // parts[0] = selected folder name (skip)
                // parts[1] = subfolder or filename

                if (parts.length === 2) {
                    // Root level file
                    folderFiles.push({ file, relativePath: parts[1] });
                    groups['__root__'].push(file);
                } else if (parts.length === 3) {
                    // First level subfolder
                    const albumName = parts[1];
                    folderFiles.push({ file, relativePath: `${parts[1]}/${parts[2]}` });
                    if (!groups[albumName]) groups[albumName] = [];
                    groups[albumName].push(file);
                }
                // Deeper nesting is ignored
            });

            if (folderFiles.length === 0) {
                previewContainer.classList.add('hidden');
                uploadOptions.classList.add('hidden');
                submitBtn.disabled = true;
                return;
            }

            // Build preview with folder structure summary
            preview.innerHTML = '';

            // Show structure summary
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'folder-summary';

            const rootCount = groups['__root__'].length;
            const albumNames = Object.keys(groups).filter(k => k !== '__root__');

            let summaryHtml = '<div class="folder-structure">';
            if (rootCount > 0) {
                summaryHtml += `<div class="folder-item-preview">üìÑ ${rootCount} individual photo${rootCount > 1 ? 's' : ''}</div>`;
            }
            albumNames.forEach(name => {
                const count = groups[name].length;
                summaryHtml += `<div class="folder-item-preview">üìÅ "${name}" (${count} photo${count > 1 ? 's' : ''})</div>`;
            });
            summaryHtml += '</div>';
            summaryDiv.innerHTML = summaryHtml;
            preview.appendChild(summaryDiv);

            // Show some thumbnails
            const thumbsDiv = document.createElement('div');
            thumbsDiv.className = 'preview-thumbs';
            const previewFiles = folderFiles.slice(0, 8);
            previewFiles.forEach(({ file }) => {
                if (file.type.startsWith('video/')) {
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(file);
                    video.className = 'preview-thumb';
                    video.title = file.name;
                    video.muted = true;
                    video.preload = 'metadata';
                    thumbsDiv.appendChild(video);
                } else {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.className = 'preview-thumb';
                    img.title = file.name;
                    thumbsDiv.appendChild(img);
                }
            });
            if (folderFiles.length > 8) {
                const moreDiv = document.createElement('div');
                moreDiv.className = 'preview-more';
                moreDiv.textContent = `+${folderFiles.length - 8} more`;
                thumbsDiv.appendChild(moreDiv);
            }
            preview.appendChild(thumbsDiv);

            const skippedNested = files.filter(f => f.webkitRelativePath.split('/').length > 3 && isValidMedia(f)).length;
            let countText = `${folderFiles.length} file${folderFiles.length > 1 ? 's' : ''} selected`;
            if (skippedNested > 0) {
                countText += ` (${skippedNested} nested skipped)`;
            }
            previewCount.textContent = countText;

            previewContainer.classList.remove('hidden');
            uploadOptions.classList.remove('hidden');
            submitBtn.disabled = false;

            // Hide album checkbox in folder mode
            albumCheckbox.closest('.upload-option').style.display = 'none';
        }

        clearFilesBtn.onclick = () => {
            fileInput.value = '';
            folderInput.value = '';
            folderFiles = [];
            updatePreview([]);
        };

        // Drag & drop for drop zone in modal
        dropZone.ondragover = (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        };
        dropZone.ondragleave = () => dropZone.classList.remove('drag-over');
        dropZone.ondrop = (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const dt = new DataTransfer();
            for (const file of e.dataTransfer.files) {
                if (isValidMedia(file)) {
                    dt.items.add(file);
                }
            }
            fileInput.files = dt.files;
            updatePreview(dt.files);
        };

        // File upload
        submitBtn.onclick = async () => {
            // Check that we have a valid folder
            if (!currentFolderId) {
                alert('No folder selected. Please navigate to a folder first.');
                return;
            }

            isUploading = true;
            submitBtn.disabled = true;
            cancelBtn.disabled = true;
            progressDiv.classList.remove('hidden');

            const useAiTags = autoAiTagsCheckbox.checked;
            const manualTags = tagsInput.value.trim()
                .split(',')
                .map(t => t.trim().toLowerCase())
                .filter(t => t.length > 0);

            let uploadedIds = [];

            try {
                if (uploadMode === 'folder') {
                    // Bulk folder upload
                    if (!folderFiles.length) return;

                    progressText.textContent = `Uploading ${folderFiles.length} files...`;
                    progressFill.style.width = '30%';

                    const formData = new FormData();
                    const paths = [];

                    folderFiles.forEach(({ file, relativePath }) => {
                        formData.append('files', file);
                        paths.push(relativePath);
                    });

                    formData.append('paths', JSON.stringify(paths));
                    formData.append('folder_id', currentFolderId);

                    progressFill.style.width = '50%';
                    const resp = await csrfFetch('/upload-bulk', { method: 'POST', body: formData });

                    if (!resp.ok) {
                        const err = await resp.json();
                        throw new Error(err.detail || 'Upload failed');
                    }

                    const data = await resp.json();
                    progressFill.style.width = '90%';

                    // Build result message
                    const s = data.summary;
                    let msg = `Uploaded: ${s.individual_photos} photos`;
                    if (s.albums_created > 0) {
                        msg += `, ${s.albums_created} albums (${s.photos_in_albums} photos)`;
                    }
                    if (s.failed > 0) {
                        msg += ` | ${s.failed} failed`;
                    }
                    if (s.skipped_nested > 0) {
                        msg += ` | ${s.skipped_nested} nested skipped`;
                    }
                    progressText.textContent = msg;

                    // Note: bulk upload doesn't return individual photo IDs for tagging
                    // AI tags and manual tags won't be applied to bulk uploads
                    progressFill.style.width = '100%';

                } else {
                    // Regular file upload
                    const files = Array.from(fileInput.files).filter(isValidMedia);
                    if (!files.length) return;

                    const isAlbum = albumCheckbox.checked && files.length > 1;

                    if (isAlbum) {
                        progressText.textContent = 'Uploading album...';
                        progressFill.style.width = '50%';

                        const formData = new FormData();
                        for (const file of files) {
                            formData.append('files', file);
                        }
                        formData.append('folder_id', currentFolderId);
                        const resp = await csrfFetch('/upload-album', { method: 'POST', body: formData });
                        if (!resp.ok) {
                            const err = await resp.json();
                            throw new Error(err.detail || 'Upload failed');
                        }
                        const data = await resp.json();
                        uploadedIds = data.photos.map(p => p.id);
                        progressFill.style.width = '100%';
                    } else {
                        for (let i = 0; i < files.length; i++) {
                            progressText.textContent = `Uploading ${i + 1}/${files.length}...`;
                            progressFill.style.width = `${((i + 1) / files.length) * 100}%`;

                            const formData = new FormData();
                            formData.append('file', files[i]);
                            formData.append('folder_id', currentFolderId);
                            const resp = await csrfFetch('/upload', { method: 'POST', body: formData });
                            if (!resp.ok) {
                                const err = await resp.json();
                                throw new Error(err.detail || 'Upload failed');
                            }
                            const data = await resp.json();
                            uploadedIds.push(data.id);
                        }
                    }

                    // Apply AI tags if requested
                    if (useAiTags && uploadedIds.length > 0) {
                        progressText.textContent = 'Generating AI tags...';
                        await csrfFetch('/api/photos/batch-ai-tags', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ photo_ids: uploadedIds })
                        });
                    }

                    // Apply manual tags if provided
                    if (manualTags.length > 0 && uploadedIds.length > 0) {
                        progressText.textContent = 'Applying tags...';
                        for (const photoId of uploadedIds) {
                            for (const tag of manualTags) {
                                await csrfFetch(`/api/photos/${photoId}/tag`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ tag: tag, category_id: 6 })
                                });
                            }
                        }
                    }

                    progressText.textContent = 'Done!';
                }

                setTimeout(() => location.reload(), 1000);

            } catch (err) {
                console.error('Upload error:', err);
                progressText.textContent = 'Upload failed: ' + err.message;
                isUploading = false;
                submitBtn.disabled = false;
                cancelBtn.disabled = false;
            }
        };
    </script>

    <script>
        // === Sidebar and Folder Management ===
        let folderTree = [];
        let editingFolderId = null;

        // Sidebar elements
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const folderTreeContainer = document.getElementById('folder-tree');
        const createFolderBtn = document.getElementById('create-folder-btn');

        // Folder modal elements
        const folderModal = document.getElementById('folder-modal');
        const folderModalTitle = document.getElementById('folder-modal-title');
        const folderNameInput = document.getElementById('folder-name-input');
        const folderParentSelect = document.getElementById('folder-parent-select');
        const folderCancelBtn = document.getElementById('folder-cancel-btn');
        const folderSubmitBtn = document.getElementById('folder-submit-btn');
        const folderModalClose = folderModal.querySelector('.close');

        // Mobile sidebar toggle
        sidebarToggle.onclick = () => {
            sidebar.classList.toggle('open');
            sidebarOverlay.classList.toggle('visible');
        };

        sidebarOverlay.onclick = () => {
            sidebar.classList.remove('open');
            sidebarOverlay.classList.remove('visible');
        };

        // Close sidebar when clicking outside of it
        document.addEventListener('click', (e) => {
            if (!sidebar.classList.contains('open')) return;

            // Don't close if clicking on sidebar itself or toggle button
            if (e.target.closest('#sidebar') || e.target.closest('#sidebar-toggle')) {
                return;
            }

            sidebar.classList.remove('open');
            sidebarOverlay.classList.remove('visible');
        });

        // Mobile swipe to close sidebar
        let sidebarTouchStartX = 0;
        let sidebarTouchStartY = 0;
        const sidebarSwipeThreshold = 50;

        sidebar.addEventListener('touchstart', (e) => {
            sidebarTouchStartX = e.changedTouches[0].screenX;
            sidebarTouchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        sidebar.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const deltaX = touchEndX - sidebarTouchStartX;
            const deltaY = Math.abs(touchEndY - sidebarTouchStartY);

            // Swipe left to close (sidebar is on the left side)
            if (deltaX < -sidebarSwipeThreshold && deltaY < sidebarSwipeThreshold) {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('visible');
            }
        }, { passive: true });

        // Load folder tree
        async function loadFolderTree() {
            try {
                const resp = await fetch('/api/folders');
                folderTree = await resp.json();
                renderFolderTree();
                updateParentSelect();
            } catch (err) {
                console.error('Failed to load folders:', err);
            }
        }

        // Render folder tree recursively
        function renderFolderTree() {
            const myFolders = folderTree.filter(f => f.permission === 'owner');
            const sharedFolders = folderTree.filter(f => f.permission !== 'owner');

            let html = '';

            // My Folders section
            if (myFolders.length > 0) {
                html += '<div class="folder-section">';
                html += '<div class="folder-section-header">My Folders</div>';
                html += buildTreeHTML(null, 0, myFolders);
                html += '</div>';
            }

            // Shared with me section
            if (sharedFolders.length > 0) {
                html += '<div class="folder-section">';
                html += '<div class="folder-section-header">Shared with me</div>';
                html += sharedFolders.map(folder => buildFolderItem(folder, 0, false)).join('');
                html += '</div>';
            }

            folderTreeContainer.innerHTML = html || '<div class="no-folders">No folders yet</div>';
        }

        function buildTreeHTML(parentId, level, folders = folderTree) {
            const children = folders.filter(f => f.parent_id === parentId && f.permission === 'owner');
            if (children.length === 0) return '';

            return children.map(folder => buildFolderItem(folder, level, true) + buildTreeHTML(folder.id, level + 1, folders)).join('');
        }

        function buildFolderItem(folder, level, isOwn) {
            const isActive = folder.id === currentFolderId;
            const permission = folder.permission;
            const shareStatus = folder.share_status;
            const photoCount = folder.photo_count || 0;

            // Icon and class based on ownership and share status
            let folderIcon;
            let folderClass = '';

            if (permission === 'owner') {
                // Own folder - show share status
                if (shareStatus === 'has_editors') {
                    // Shared with editors (orange)
                    folderClass = 'shared-editors';
                    folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                        <path d="M15 12l-3 3m0 0l-3-3m3 3V9"/>
                    </svg>`;
                } else if (shareStatus === 'has_viewers') {
                    // Shared with viewers only (green)
                    folderClass = 'shared-viewers';
                    folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                        <circle cx="12" cy="13" r="2"/><path d="M18 13c-1.5 2-3.5 3-6 3s-4.5-1-6-3c1.5-2 3.5-3 6-3s4.5 1 6 3z"/>
                    </svg>`;
                } else {
                    // Private folder (default gray with lock)
                    folderClass = 'private';
                    folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                        <rect x="9" y="11" width="6" height="5" rx="1"/><path d="M10 11V9a2 2 0 1 1 4 0v2"/>
                    </svg>`;
                }
            } else if (permission === 'editor') {
                // Shared folder where I'm editor (orange border)
                folderClass = 'incoming-editor';
                folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    <path d="M12 16V9m0 0l3 3m-3-3l-3 3"/>
                </svg>`;
            } else {
                // Shared folder where I'm viewer (green border)
                folderClass = 'incoming-viewer';
                folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    <circle cx="12" cy="13" r="2"/><path d="M18 13c-1.5 2-3.5 3-6 3s-4.5-1-6-3c1.5-2 3.5-3 6-3s4.5 1 6 3z"/>
                </svg>`;
            }

            const ownerInfo = !isOwn && folder.owner_name ? `<span class="folder-owner">${escapeHtml(folder.owner_name)}</span>` : '';

            const actionsHtml = isOwn ? `
                <div class="folder-actions-inline">
                    <button class="folder-action-btn" onclick="event.stopPropagation(); openEditFolder('${folder.id}')" title="Edit">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                    </button>
                    <button class="folder-action-btn" onclick="event.stopPropagation(); deleteFolder('${folder.id}')" title="Delete">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                    </button>
                </div>` : '';

            return `
                <div class="folder-item-wrapper" style="padding-left: ${level * 16}px">
                    <div class="folder-item ${folderClass} ${isActive ? 'active' : ''}"
                         data-folder-id="${folder.id}"
                         onclick="navigateToFolder('${folder.id}')">
                        ${folderIcon}
                        <span class="folder-name">${escapeHtml(folder.name)}</span>
                        ${ownerInfo}
                        <span class="folder-count">${photoCount}</span>
                    </div>
                    ${actionsHtml}
                </div>
            `;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function navigateToFolder(folderId) {
            window.location.href = `/?folder_id=${folderId}`;
        }

        // Update parent folder select options
        function updateParentSelect() {
            folderParentSelect.innerHTML = '<option value="">Root level</option>';
            folderTree.forEach(folder => {
                // Only show owned folders as parent options
                if (folder.permission !== 'owner') return;
                // Don't show current folder as parent option when editing
                if (editingFolderId && folder.id === editingFolderId) return;
                const opt = document.createElement('option');
                opt.value = folder.id;
                opt.textContent = folder.name;
                folderParentSelect.appendChild(opt);
            });
        }

        // Folder modal functions
        function openCreateFolder() {
            editingFolderId = null;
            folderModalTitle.textContent = 'Create Folder';
            folderSubmitBtn.textContent = 'Create';
            folderNameInput.value = '';
            folderParentSelect.value = currentFolderId || '';
            updateParentSelect();
            folderModal.classList.remove('hidden');
            folderNameInput.focus();
        }

        function openEditFolder(folderId) {
            const folder = folderTree.find(f => f.id === folderId);
            if (!folder) return;

            editingFolderId = folderId;
            folderModalTitle.textContent = 'Edit Folder';
            folderSubmitBtn.textContent = 'Save';
            folderNameInput.value = folder.name;
            folderParentSelect.value = folder.parent_id || '';
            updateParentSelect();
            folderModal.classList.remove('hidden');
            folderNameInput.focus();
        }

        function closeFolderModal() {
            folderModal.classList.add('hidden');
            editingFolderId = null;
        }

        createFolderBtn.onclick = openCreateFolder;
        folderCancelBtn.onclick = closeFolderModal;
        folderModalClose.onclick = closeFolderModal;
        folderModal.onclick = (e) => {
            if (e.target === folderModal) closeFolderModal();
        };

        // Create or update folder
        folderSubmitBtn.onclick = async () => {
            const name = folderNameInput.value.trim();
            if (!name) {
                alert('Please enter a folder name');
                return;
            }

            const parentId = folderParentSelect.value || null;

            try {
                if (editingFolderId) {
                    // Update existing folder
                    await csrfFetch(`/api/folders/${editingFolderId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name })
                    });
                } else {
                    // Create new folder
                    await csrfFetch('/api/folders', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, parent_id: parentId })
                    });
                }
                closeFolderModal();
                loadFolderTree();
            } catch (err) {
                console.error('Folder operation failed:', err);
                alert('Operation failed');
            }
        };

        // Delete folder
        async function deleteFolder(folderId) {
            const folder = folderTree.find(f => f.id === folderId);
            if (!folder) return;

            if (!confirm(`Delete folder "${folder.name}" and all its contents?`)) return;

            try {
                await csrfFetch(`/api/folders/${folderId}`, { method: 'DELETE' });
                if (folderId === currentFolderId) {
                    // Navigate to parent or root
                    window.location.href = folder.parent_id ? `/?folder_id=${folder.parent_id}` : '/';
                } else {
                    loadFolderTree();
                }
            } catch (err) {
                console.error('Delete failed:', err);
                alert('Delete failed');
            }
        }

        // === Share Modal ===
        let shareModalFolderId = null;
        let selectedUserId = null;
        let searchTimeout = null;

        function openShareModal(folderId) {
            shareModalFolderId = folderId;
            document.getElementById('share-modal').classList.remove('hidden');
            document.getElementById('user-search-input').value = '';
            document.getElementById('user-search-results').classList.add('hidden');
            document.getElementById('add-permission-form').classList.add('hidden');
            loadPermissions();
        }

        function closeShareModal() {
            document.getElementById('share-modal').classList.add('hidden');
            shareModalFolderId = null;
            selectedUserId = null;
        }

        async function loadPermissions() {
            if (!shareModalFolderId) return;

            try {
                const resp = await fetch(`/api/folders/${shareModalFolderId}/permissions`);
                const data = await resp.json();
                renderPermissions(data.permissions || []);
            } catch (err) {
                console.error('Failed to load permissions:', err);
            }
        }

        function renderPermissions(permissions) {
            const container = document.getElementById('permissions-list');

            if (permissions.length === 0) {
                container.innerHTML = '<p class="no-permissions">No one else has access</p>';
                return;
            }

            container.innerHTML = permissions.map(p => `
                <div class="permission-item" data-user-id="${p.user_id}">
                    <span class="permission-user">${escapeHtml(p.display_name || p.username)}</span>
                    <select class="permission-select" onchange="updatePermission(${p.user_id}, this.value)">
                        <option value="viewer" ${p.permission === 'viewer' ? 'selected' : ''}>Viewer</option>
                        <option value="editor" ${p.permission === 'editor' ? 'selected' : ''}>Editor</option>
                    </select>
                    <button class="btn-remove-permission" onclick="removePermission(${p.user_id})" title="Remove">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
            `).join('');
        }

        // User search
        document.getElementById('user-search-input')?.addEventListener('input', function(e) {
            const query = e.target.value.trim();

            clearTimeout(searchTimeout);
            if (query.length < 2) {
                document.getElementById('user-search-results').classList.add('hidden');
                return;
            }

            searchTimeout = setTimeout(() => searchUsers(query), 300);
        });

        // Hide suggestions on blur (with delay to allow clicking on results)
        document.getElementById('user-search-input')?.addEventListener('blur', function() {
            setTimeout(() => {
                document.getElementById('user-search-results').classList.add('hidden');
            }, 200);
        });

        // Show suggestions on focus if there's a query
        document.getElementById('user-search-input')?.addEventListener('focus', function(e) {
            const query = e.target.value.trim();
            if (query.length >= 2) {
                searchUsers(query);
            }
        });

        async function searchUsers(query) {
            try {
                const resp = await fetch(`/api/users/search?q=${encodeURIComponent(query)}`);
                const data = await resp.json();
                renderSearchResults(data.users || []);
            } catch (err) {
                console.error('Search failed:', err);
            }
        }

        function renderSearchResults(users) {
            const container = document.getElementById('user-search-results');

            if (users.length === 0) {
                container.innerHTML = '<div class="no-results">No users found</div>';
            } else {
                container.innerHTML = users.map(u => `
                    <div class="search-result-item" onclick="selectUser(${u.id}, '${escapeHtml(u.display_name || u.username)}')">
                        ${escapeHtml(u.display_name || u.username)}
                        <span class="search-result-username">@${escapeHtml(u.username)}</span>
                    </div>
                `).join('');
            }
            container.classList.remove('hidden');
        }

        function selectUser(userId, displayName) {
            selectedUserId = userId;
            document.getElementById('user-search-results').classList.add('hidden');
            document.getElementById('user-search-input').value = '';
            document.getElementById('selected-user-name').textContent = displayName;
            document.getElementById('add-permission-form').classList.remove('hidden');
        }

        document.getElementById('cancel-add-btn')?.addEventListener('click', function() {
            document.getElementById('add-permission-form').classList.add('hidden');
            selectedUserId = null;
        });

        document.getElementById('add-permission-btn')?.addEventListener('click', async function() {
            if (!selectedUserId || !shareModalFolderId) return;

            const permission = document.getElementById('permission-level-select').value;

            try {
                await csrfFetch(`/api/folders/${shareModalFolderId}/permissions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: selectedUserId, permission })
                });
                document.getElementById('add-permission-form').classList.add('hidden');
                selectedUserId = null;
                loadPermissions();
            } catch (err) {
                console.error('Add permission failed:', err);
                alert('Failed to add permission');
            }
        });

        async function updatePermission(userId, permission) {
            if (!shareModalFolderId) return;

            try {
                await csrfFetch(`/api/folders/${shareModalFolderId}/permissions/${userId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ permission })
                });
            } catch (err) {
                console.error('Update permission failed:', err);
                alert('Failed to update permission');
                loadPermissions();
            }
        }

        async function removePermission(userId) {
            if (!shareModalFolderId) return;
            if (!confirm('Remove access for this user?')) return;

            try {
                await csrfFetch(`/api/folders/${shareModalFolderId}/permissions/${userId}`, {
                    method: 'DELETE'
                });
                loadPermissions();
            } catch (err) {
                console.error('Remove permission failed:', err);
                alert('Failed to remove permission');
            }
        }

        // Sort selector handler
        const sortSelect = document.getElementById('sort-select');
        if (sortSelect) {
            sortSelect.addEventListener('change', async function() {
                const sortBy = this.value;

                // Save preference via API
                if (currentFolderId) {
                    try {
                        await csrfFetch(`/api/folders/${currentFolderId}/sort`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ sort_by: sortBy })
                        });
                    } catch (e) {
                        console.error('Failed to save sort preference:', e);
                    }
                }

                // Reload page with new sort (will be read from saved preference)
                const url = new URL(window.location);
                url.searchParams.delete('sort'); // Remove sort param, use saved preference
                window.location.href = url.toString();
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', loadFolderTree);
    </script>

    {% block scripts %}{% endblock %}
</body>
</html>
