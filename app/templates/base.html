<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <title>{% block title %}Synth{% endblock %}</title>
    <link rel="icon" type="image/svg+xml" href="{{ base_url }}/static/favicon.svg">
    <link rel="stylesheet" href="{{ base_url }}/static/style.css">
    
    <!-- Global config -->
    <script>
        window.SYNTH_BASE_URL = '{{ base_url }}';
        {% if user %}
        window.SYNTH_USER_ID = {{ user.id }};
        {% endif %}
    </script>
    
    <!-- Core utilities -->
    <script src="{{ base_url }}/static/js/core.js"></script>
    <!-- Navigation -->
    <script src="{{ base_url }}/static/js/navigation.js"></script>
    <!-- Sidebar -->
    <script src="{{ base_url }}/static/js/sidebar.js"></script>
    <!-- Upload -->
    <script src="{{ base_url }}/static/js/upload.js"></script>
    <!-- Gallery -->
    <script src="{{ base_url }}/static/js/gallery.js"></script>
    <!-- Safes -->
    <script src="{{ base_url }}/static/js/safes.js"></script>
    <!-- Initialization (last) -->
    <script src="{{ base_url }}/static/js/init.js"></script>
</head>
<body>
    <div class="app-layout">
        <!-- Sidebar -->
        <aside id="sidebar" class="sidebar">
            <div class="sidebar-logo">
                <a href="{{ base_url }}/" class="logo" onclick="event.preventDefault(); navigateToDefaultFolder();"><img src="{{ base_url }}/static/favicon.svg" alt="" class="logo-icon">Synth</a>
            </div>
            <div class="folder-tree" id="folder-tree">
                <!-- Folder tree rendered by JS -->
            </div>
            {% if user %}
            <div class="sidebar-user">
                <span class="user-name">{{ user.display_name }}</span>
                <a href="{{ base_url }}/settings" class="sidebar-settings-btn" title="Settings">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                    </svg>
                </a>
            </div>
            {% endif %}
        </aside>

        <!-- Main content area -->
        <div class="main-content">
            <main>
                {% block content %}{% endblock %}
            </main>
        </div>
    </div>

    <!-- Sidebar overlay for mobile -->
    <div id="sidebar-overlay" class="sidebar-overlay hidden"></div>

    <!-- Upload modal -->
    <div id="upload-modal" class="modal hidden">
        <div class="modal-content upload-modal-content">
            <span class="close">&times;</span>
            <h2>Upload Media</h2>

            <div class="upload-mode-tabs">
                <button type="button" class="upload-tab active" data-mode="files">Files</button>
                <button type="button" class="upload-tab" data-mode="folder">Folder</button>
            </div>

            <div id="drop-zone" class="drop-zone">
                <input type="file" id="file-input" accept="image/*,video/mp4,video/webm" multiple style="display:none">
                <input type="file" id="folder-input" webkitdirectory multiple style="display:none">
                <div class="drop-zone-text" id="files-drop-text">
                    <span class="drop-icon">+</span>
                    <p>Drag & drop images or videos here</p>
                    <p class="drop-hint">or click to select files (jpg, png, gif, webp, mp4, webm)</p>
                </div>
                <div class="drop-zone-text hidden" id="folder-drop-text">
                    <span class="drop-icon">üìÅ</span>
                    <p>Click to select a folder</p>
                    <p class="drop-hint">Root files ‚Üí photos, subfolders ‚Üí albums</p>
                </div>
            </div>

            <div id="upload-preview-container" class="upload-preview-container hidden">
                <div class="preview-header">
                    <span id="preview-count">0 files selected</span>
                    <button type="button" id="clear-files-btn" class="btn btn-small btn-secondary">Clear</button>
                </div>
                <div id="upload-preview" class="upload-preview"></div>
            </div>

            <div id="upload-options" class="upload-options hidden">
                <div class="upload-option">
                    <label class="checkbox-label">
                        <input type="checkbox" id="upload-as-album">
                        <span class="checkmark"></span>
                        Upload as album
                    </label>
                </div>

                <div class="upload-option">
                    <label class="checkbox-label">
                        <input type="checkbox" id="auto-ai-tags">
                        <span class="checkmark"></span>
                        Auto-generate AI tags
                    </label>
                </div>

                <div id="manual-tags-section" class="manual-tags-section">
                    <label>Add tags:</label>
                    <input type="text" id="upload-tags-input" placeholder="tag1, tag2, tag3..." autocomplete="off">
                    <p class="input-hint">Comma-separated tags to apply to all photos</p>
                </div>
            </div>

            <div id="upload-progress" class="upload-progress hidden">
                <div class="progress-bar"><div id="progress-fill" class="progress-fill"></div></div>
                <span id="progress-text" class="progress-text">Uploading...</span>
            </div>

            <div id="upload-actions" class="upload-actions">
                <button type="button" id="cancel-upload-btn" class="btn btn-secondary">Cancel</button>
                <button type="button" id="submit-upload-btn" class="btn" disabled>Upload</button>
            </div>
        </div>
    </div>

    <!-- Folder modal -->
    <div id="folder-modal" class="modal hidden">
        <div class="modal-content folder-modal-content">
            <span class="close">&times;</span>
            <h2 id="folder-modal-title">Create Folder</h2>

            <div class="form-group">
                <label for="folder-name-input">Folder name:</label>
                <input type="text" id="folder-name-input" placeholder="My Folder" autocomplete="off">
            </div>

            <div class="form-group">
                <label for="folder-parent-select">Parent folder:</label>
                <select id="folder-parent-select">
                    <option value="">Root level</option>
                </select>
            </div>

            <div id="default-folder-section" class="form-group hidden">
                <button type="button" id="set-default-folder-btn" class="btn btn-secondary btn-block">
                    Set as default folder
                </button>
            </div>

            <div id="delete-folder-section" class="form-group hidden">
                <button type="button" id="delete-folder-btn" class="btn btn-danger btn-block">
                    Delete folder
                </button>
            </div>

            <div class="modal-actions">
                <button type="button" id="folder-cancel-btn" class="btn btn-secondary">Cancel</button>
                <button type="button" id="folder-submit-btn" class="btn">Create</button>
            </div>
        </div>
    </div>

    <!-- Safe Create modal -->
    <div id="safe-modal" class="modal hidden">
        <div class="modal-content safe-modal-content">
            <span class="close" onclick="closeSafeModal()">&times;</span>
            <h2 id="safe-modal-title">Create Safe</h2>

            <div class="form-group">
                <label for="safe-name-input">Safe name:</label>
                <input type="text" id="safe-name-input" placeholder="My Safe" autocomplete="off">
            </div>

            <div class="form-group">
                <label>Protection method:</label>
                <div class="safe-protection-options">
                    <label class="radio-label">
                        <input type="radio" name="safe-protection" value="password" checked>
                        <span class="radio-text">Password</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="safe-protection" value="webauthn">
                        <span class="radio-text">Hardware Key</span>
                    </label>
                </div>
            </div>

            <form id="safe-form" onsubmit="event.preventDefault();" autocomplete="off">
                <!-- Hidden username field for accessibility and password manager compatibility -->
                <input type="text" id="safe-username" name="username" value="synth-safe-user" autocomplete="username" style="position: absolute; opacity: 0; pointer-events: none;" aria-hidden="true">
                
                <!-- Password protection section -->
                <div id="safe-password-section" class="form-group safe-password-group">
                    <label for="safe-password-input" class="safe-input-label">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                        </svg>
                        Create Password
                    </label>
                    <div class="safe-input-wrapper">
                        <input type="password" id="safe-password-input" class="safe-password-input" placeholder="Enter a strong password (min 8 chars)" autocomplete="new-password" minlength="8" required>
                        <button type="button" class="password-toggle" onclick="toggleSafePassword('safe-password-input', this)" aria-label="Show password">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                                <circle cx="12" cy="12" r="3"/>
                            </svg>
                        </button>
                    </div>
                    <div class="safe-password-strength" id="safe-password-strength">
                        <div class="strength-bar"></div>
                    </div>
                    <p class="safe-input-hint">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 16v-4M12 8h.01"/>
                        </svg>
                        This password protects your safe. Don't forget it - it cannot be recovered!
                    </p>
                </div>

                <!-- WebAuthn protection section -->
                <div id="safe-webauthn-section" class="form-group hidden">
                    <label class="safe-input-label">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
                        </svg>
                        Select Hardware Key
                    </label>
                    <div class="safe-select-wrapper">
                        <select id="safe-webauthn-select" class="safe-select">
                            <option value="">Loading credentials...</option>
                        </select>
                    </div>
                    <p class="safe-input-hint">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 16v-4M12 8h.01"/>
                        </svg>
                        You'll need this hardware key every time you access the safe
                    </p>
                </div>

                <div class="modal-actions safe-modal-actions">
                    <button type="button" onclick="closeSafeModal()" class="btn btn-secondary safe-cancel-btn">Cancel</button>
                    <button type="submit" id="safe-submit-btn" class="btn safe-submit-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
                        </svg>
                        Create Safe
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Safe Unlock modal -->
    <div id="safe-unlock-modal" class="modal hidden">
        <div class="modal-content safe-modal-content">
            <span class="close" onclick="closeSafeUnlockModal()">&times;</span>
            <h2 id="safe-unlock-title">Unlock Safe</h2>
            <p id="safe-unlock-description" class="modal-description">Enter password to unlock</p>

            <form id="safe-unlock-form" onsubmit="event.preventDefault();" autocomplete="off">
                <!-- Hidden username field for accessibility -->
                <input type="text" id="safe-unlock-username" name="username" value="synth-safe-user" autocomplete="username" style="position: absolute; opacity: 0; pointer-events: none;" aria-hidden="true">
                
                <!-- Password unlock section -->
                <div id="safe-unlock-password-section" class="form-group safe-password-group">
                    <label for="safe-unlock-password-input" class="safe-input-label">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                        </svg>
                        Enter Password
                    </label>
                    <div class="safe-input-wrapper">
                        <input type="password" id="safe-unlock-password-input" class="safe-password-input" placeholder="Enter your safe password" autocomplete="current-password" required autofocus>
                        <button type="button" class="password-toggle" onclick="toggleSafePassword('safe-unlock-password-input', this)" aria-label="Show password">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                                <circle cx="12" cy="12" r="3"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- WebAuthn unlock section -->
                <div id="safe-unlock-webauthn-section" class="form-group hidden">
                    <div class="webauthn-prompt">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="48" height="48">
                            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
                        </svg>
                        <p>Authenticate with your hardware key to unlock</p>
                    </div>
                </div>

                <div class="modal-actions safe-modal-actions">
                    <button type="button" onclick="closeSafeUnlockModal()" class="btn btn-secondary safe-cancel-btn">Cancel</button>
                    <button type="submit" id="safe-unlock-submit-btn" class="btn safe-submit-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                            <circle cx="12" cy="12" r="1" fill="currentColor"/>
                        </svg>
                        Unlock
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Safe Edit modal -->
    <div id="safe-edit-modal" class="modal hidden">
        <div class="modal-content folder-modal-content">
            <span class="close" onclick="closeSafeEditModal()">&times;</span>
            <h2 id="safe-edit-modal-title">Edit Safe</h2>

            <div class="form-group">
                <label for="safe-edit-name-input">Safe name:</label>
                <input type="text" id="safe-edit-name-input" placeholder="My Safe" autocomplete="off">
            </div>

            <div id="delete-safe-section" class="form-group">
                <button type="button" id="delete-safe-btn" class="btn btn-danger btn-block">
                    Delete safe
                </button>
            </div>

            <div class="modal-actions">
                <button type="button" onclick="closeSafeEditModal()" class="btn btn-secondary">Cancel</button>
                <button type="button" id="safe-edit-submit-btn" class="btn">Save</button>
            </div>
        </div>
    </div>

    <!-- Include SafeCrypto -->
    <script src="{{ base_url }}/static/js/crypto/safe-crypto.js"></script>

    <!-- Share modal -->
    <div id="share-modal" class="modal hidden">
        <div class="modal-content share-modal-content">
            <span class="close" onclick="closeShareModal()">&times;</span>
            <h2>Share Folder</h2>

            <!-- User search -->
            <div class="share-search">
                <input type="text" id="user-search-input" placeholder="Search users..." autocomplete="off">
                <div id="user-search-results" class="user-search-results hidden"></div>
            </div>

            <!-- Add permission form -->
            <div id="add-permission-form" class="add-permission-form hidden">
                <span id="selected-user-name"></span>
                <select id="permission-level-select">
                    <option value="viewer">Viewer (view only)</option>
                    <option value="editor">Editor (can upload)</option>
                </select>
                <button type="button" id="add-permission-btn" class="btn">Add</button>
                <button type="button" id="cancel-add-btn" class="btn btn-secondary">Cancel</button>
            </div>

            <!-- Current permissions list -->
            <div class="permissions-section">
                <h3>People with access</h3>
                <div id="permissions-list" class="permissions-list">
                    <!-- Dynamically populated -->
                </div>
            </div>

            <div class="modal-actions">
                <button type="button" onclick="closeShareModal()" class="btn">Done</button>
            </div>
        </div>
    </div>

    <script>
        // Get current folder ID from URL (will be moved to init.js in Phase 7)
        const urlParams = new URLSearchParams(window.location.search);
        window.currentFolderId = urlParams.get('folder_id');
        console.log('[DEBUG] Current folder ID:', window.currentFolderId);
    </script>

    <script>
        // Upload modal elements
        const modal = document.getElementById('upload-modal');
        const closeBtn = modal.querySelector('.close');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const folderInput = document.getElementById('folder-input');
        const filesDropText = document.getElementById('files-drop-text');
        const folderDropText = document.getElementById('folder-drop-text');
        const previewContainer = document.getElementById('upload-preview-container');
        const preview = document.getElementById('upload-preview');
        const previewCount = document.getElementById('preview-count');
        const clearFilesBtn = document.getElementById('clear-files-btn');
        const uploadOptions = document.getElementById('upload-options');
        const albumCheckbox = document.getElementById('upload-as-album');
        const autoAiTagsCheckbox = document.getElementById('auto-ai-tags');
        const tagsInput = document.getElementById('upload-tags-input');
        const progressDiv = document.getElementById('upload-progress');
        const progressFill = document.getElementById('progress-fill');
        const progressText = document.getElementById('progress-text');
        const cancelBtn = document.getElementById('cancel-upload-btn');
        const submitBtn = document.getElementById('submit-upload-btn');

        let isUploading = false;
        let uploadMode = 'files'; // 'files' or 'folder'
        let folderFiles = []; // Store files with their relative paths for folder mode
        let selectedFiles = []; // Store selected files for regular upload (accumulates across selections)
        
        // Max file size (1GB) - should match nginx client_max_body_size
        const MAX_FILE_SIZE = 1024 * 1024 * 1024;

        // Open/close modal
        const folderUploadBtn = document.getElementById('folder-upload-btn');
        if (folderUploadBtn) {
            folderUploadBtn.onclick = () => modal.classList.remove('hidden');
        }
        closeBtn.onclick = () => closeModal();
        cancelBtn.onclick = () => closeModal();
        modal.onclick = (e) => {
            if (e.target === modal && !isUploading) closeModal();
        };

        function closeModal() {
            if (isUploading) return;
            modal.classList.add('hidden');
            resetUploadForm();
        }

        // Close upload modal on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
                e.preventDefault();
                closeModal();
            }
        });

        function resetUploadForm() {
            fileInput.value = '';
            folderInput.value = '';
            folderFiles = [];
            selectedFiles = [];
            preview.innerHTML = '';
            previewContainer.classList.add('hidden');
            uploadOptions.classList.add('hidden');
            progressDiv.classList.add('hidden');
            albumCheckbox.checked = false;
            autoAiTagsCheckbox.checked = false;
            tagsInput.value = '';
            submitBtn.disabled = true;
            progressFill.style.width = '0%';
            // Reset to files mode
            setUploadMode('files');
        }

        // Upload mode tabs
        document.querySelectorAll('.upload-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const mode = tab.dataset.mode;
                setUploadMode(mode);
            });
        });

        function setUploadMode(mode) {
            uploadMode = mode;
            document.querySelectorAll('.upload-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.mode === mode);
            });

            if (mode === 'folder') {
                filesDropText.classList.add('hidden');
                folderDropText.classList.remove('hidden');
                // Hide album option in folder mode (structure determines albums)
                albumCheckbox.closest('.upload-option').style.display = 'none';
            } else {
                filesDropText.classList.remove('hidden');
                folderDropText.classList.add('hidden');
                // Show album option in files mode
                albumCheckbox.closest('.upload-option').style.display = '';
            }

            // Clear current selection when switching modes
            fileInput.value = '';
            folderInput.value = '';
            folderFiles = [];
            selectedFiles = [];
            preview.innerHTML = '';
            previewContainer.classList.add('hidden');
            uploadOptions.classList.add('hidden');
            submitBtn.disabled = true;
        }

        // Handle click on drop zone
        dropZone.onclick = (e) => {
            if (e.target.tagName === 'INPUT') return;
            if (uploadMode === 'folder') {
                folderInput.click();
            } else {
                fileInput.click();
            }
        };

        // Check if file is valid media (image or video)
        function isValidMedia(file) {
            return file.type.startsWith('image/') ||
                   file.type === 'video/mp4' ||
                   file.type === 'video/webm';
        }

        // Add files to selection (accumulates across selections)
        function addFilesToSelection(files) {
            const mediaFiles = Array.from(files).filter(isValidMedia);
            
            if (mediaFiles.length === 0) return;
            
            // Add new files to selectedFiles (avoid duplicates by name+size)
            for (const file of mediaFiles) {
                const isDuplicate = selectedFiles.some(f => f.name === file.name && f.size === file.size);
                if (!isDuplicate) {
                    selectedFiles.push(file);
                }
            }
            
            renderFilePreview();
        }
        
        // Render file preview with hover-to-remove overlay
        function renderFilePreview() {
            if (selectedFiles.length === 0) {
                previewContainer.classList.add('hidden');
                uploadOptions.classList.add('hidden');
                submitBtn.disabled = true;
                return;
            }
            
            preview.innerHTML = '';
            selectedFiles.forEach((file, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'preview-item';
                wrapper.style.cssText = 'position:relative;display:inline-block;margin:5px;cursor:pointer;';
                
                // Create thumbnail
                let thumb;
                if (file.type.startsWith('video/')) {
                    thumb = document.createElement('video');
                    thumb.src = URL.createObjectURL(file);
                    thumb.muted = true;
                    thumb.preload = 'metadata';
                } else {
                    thumb = document.createElement('img');
                    thumb.src = URL.createObjectURL(file);
                }
                thumb.className = 'preview-thumb';
                thumb.title = file.name;
                thumb.style.cssText = 'display:block;';
                
                // Overlay with darkening and X
                const overlay = document.createElement('div');
                overlay.className = 'preview-overlay';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    opacity: 0;
                    transition: opacity 0.2s;
                    border-radius: 4px;
                `;
                overlay.innerHTML = '<span style="color:white;font-size:24px;font-weight:bold;">&times;</span>';
                
                // Show overlay on hover
                wrapper.onmouseenter = () => overlay.style.opacity = '1';
                wrapper.onmouseleave = () => overlay.style.opacity = '0';
                
                // Remove on click
                wrapper.onclick = (e) => {
                    e.stopPropagation();
                    removeFile(index);
                };
                
                wrapper.appendChild(thumb);
                wrapper.appendChild(overlay);
                preview.appendChild(wrapper);
            });
            
            previewCount.textContent = `${selectedFiles.length} file${selectedFiles.length > 1 ? 's' : ''} selected`;
            previewContainer.classList.remove('hidden');
            uploadOptions.classList.remove('hidden');
            submitBtn.disabled = false;
            
            // Show album option only for multiple files
            const albumOption = albumCheckbox.closest('.upload-option');
            if (selectedFiles.length > 1) {
                albumOption.style.display = '';
            } else {
                albumOption.style.display = 'none';
                albumCheckbox.checked = false;
            }
        }
        
        // Remove file from selection
        function removeFile(index) {
            selectedFiles.splice(index, 1);
            renderFilePreview();
        }

        fileInput.onchange = () => {
            addFilesToSelection(fileInput.files);
            fileInput.value = ''; // Reset input to allow selecting same files again
        };

        // Folder input handler
        folderInput.onchange = () => {
            const files = Array.from(folderInput.files);
            processFolderFiles(files);
        };

        function processFolderFiles(files) {
            // Filter and group files by relative path
            folderFiles = [];
            const groups = { '__root__': [] };

            files.forEach(file => {
                if (!isValidMedia(file)) return;

                const path = file.webkitRelativePath;
                const parts = path.split('/');
                // parts[0] = selected folder name (skip)
                // parts[1] = subfolder or filename

                if (parts.length === 2) {
                    // Root level file
                    folderFiles.push({ file, relativePath: parts[1] });
                    groups['__root__'].push(file);
                } else if (parts.length === 3) {
                    // First level subfolder
                    const albumName = parts[1];
                    folderFiles.push({ file, relativePath: `${parts[1]}/${parts[2]}` });
                    if (!groups[albumName]) groups[albumName] = [];
                    groups[albumName].push(file);
                }
                // Deeper nesting is ignored
            });

            if (folderFiles.length === 0) {
                previewContainer.classList.add('hidden');
                uploadOptions.classList.add('hidden');
                submitBtn.disabled = true;
                return;
            }

            // Build preview with folder structure summary
            preview.innerHTML = '';

            // Show structure summary
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'folder-summary';

            const rootCount = groups['__root__'].length;
            const albumNames = Object.keys(groups).filter(k => k !== '__root__');

            let summaryHtml = '<div class="folder-structure">';
            if (rootCount > 0) {
                summaryHtml += `<div class="folder-item-preview">üìÑ ${rootCount} individual photo${rootCount > 1 ? 's' : ''}</div>`;
            }
            albumNames.forEach(name => {
                const count = groups[name].length;
                summaryHtml += `<div class="folder-item-preview">üìÅ "${name}" (${count} photo${count > 1 ? 's' : ''})</div>`;
            });
            summaryHtml += '</div>';
            summaryDiv.innerHTML = summaryHtml;
            preview.appendChild(summaryDiv);

            // Show some thumbnails
            const thumbsDiv = document.createElement('div');
            thumbsDiv.className = 'preview-thumbs';
            const previewFiles = folderFiles.slice(0, 8);
            previewFiles.forEach(({ file }) => {
                if (file.type.startsWith('video/')) {
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(file);
                    video.className = 'preview-thumb';
                    video.title = file.name;
                    video.muted = true;
                    video.preload = 'metadata';
                    thumbsDiv.appendChild(video);
                } else {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.className = 'preview-thumb';
                    img.title = file.name;
                    thumbsDiv.appendChild(img);
                }
            });
            if (folderFiles.length > 8) {
                const moreDiv = document.createElement('div');
                moreDiv.className = 'preview-more';
                moreDiv.textContent = `+${folderFiles.length - 8} more`;
                thumbsDiv.appendChild(moreDiv);
            }
            preview.appendChild(thumbsDiv);

            const skippedNested = files.filter(f => f.webkitRelativePath.split('/').length > 3 && isValidMedia(f)).length;
            let countText = `${folderFiles.length} file${folderFiles.length > 1 ? 's' : ''} selected`;
            if (skippedNested > 0) {
                countText += ` (${skippedNested} nested skipped)`;
            }
            previewCount.textContent = countText;

            previewContainer.classList.remove('hidden');
            uploadOptions.classList.remove('hidden');
            submitBtn.disabled = false;

            // Hide album checkbox in folder mode
            albumCheckbox.closest('.upload-option').style.display = 'none';
        }

        clearFilesBtn.onclick = () => {
            fileInput.value = '';
            folderInput.value = '';
            folderFiles = [];
            selectedFiles = [];
            renderFilePreview();
        };

        // Drag & drop for drop zone in modal
        dropZone.ondragover = (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        };
        dropZone.ondragleave = () => dropZone.classList.remove('drag-over');
        dropZone.ondrop = (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            addFilesToSelection(e.dataTransfer.files);
        };

        // Get safe_id for a folder
        function getFolderSafeId(folderId) {
            console.log('[getFolderSafeId] Looking for folder:', folderId);
            console.log('[getFolderSafeId] folderTree available:', !!folderTree, 'length:', folderTree?.length);
            if (!folderId || !folderTree) return null;
            const folder = folderTree.find(f => f.id === folderId);
            console.log('[getFolderSafeId] Folder found:', !!folder, 'safe_id:', folder?.safe_id);
            return folder ? folder.safe_id : null;
        }

        // Encrypt file for safe upload
        async function encryptFileForSafeUpload(file, safeId) {
            console.log('[encryptFileForSafeUpload] Encrypting file for safe:', safeId);
            console.log('[encryptFileForSafeUpload] File name:', file.name, 'size:', file.size);
            console.log('[encryptFileForSafeUpload] SafeCrypto.isUnlocked:', SafeCrypto.isUnlocked(safeId));
            
            if (!SafeCrypto.isUnlocked(safeId)) {
                throw new Error('Safe is locked. Please unlock it first.');
            }
            
            try {
                const result = await SafeCrypto.encryptFileForSafe(file, safeId);
                console.log('[encryptFileForSafeUpload] Encryption successful, encrypted size:', result.encryptedFile.size);
                console.log('[encryptFileForSafeUpload] Thumbnail:', result.encryptedThumbnail ? result.encryptedThumbnail.size : 'none');
                console.log('[encryptFileForSafeUpload] Thumbnail dimensions:', result.thumbWidth, 'x', result.thumbHeight);
                return result;
            } catch (e) {
                console.error('[encryptFileForSafeUpload] Encryption failed:', e);
                throw e;
            }
        }

        // Get or create root folder for safe
        async function getSafeRootFolder(safeId) {
            // Check if root folder already exists
            const safeFolders = folderTree.filter(f => f.safe_id === safeId && !f.parent_id);
            if (safeFolders.length > 0) {
                return safeFolders[0].id;
            }
            
            // Create root folder for safe
            const resp = await csrfFetch('{{ base_url }}/api/folders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: 'Root',
                    safe_id: safeId
                })
            });
            
            if (!resp.ok) {
                throw new Error('Failed to create safe root folder');
            }
            
            const data = await resp.json();
            // Reload folder tree to include new folder
            await loadFolderTree();
            return data.folder_id;
        }

        // File upload
        submitBtn.onclick = async () => {
            let targetFolderId = window.currentFolderId;
            let targetSafeId = null;
            
            // If no folder selected but we're in a safe context
            if (!targetFolderId && window.currentSafeId) {
                // Get or create root folder for this safe
                try {
                    targetFolderId = await getSafeRootFolder(window.currentSafeId);
                    targetSafeId = window.currentSafeId;
                } catch (e) {
                    alert('Failed to prepare safe folder: ' + e.message);
                    return;
                }
            }
            
            // Check that we have a valid folder
            if (!targetFolderId) {
                alert('No folder selected. Please navigate to a folder first.');
                return;
            }
            
            // Check if uploading to a safe
            if (!targetSafeId) {
                targetSafeId = getFolderSafeId(targetFolderId);
            }
            if (targetSafeId && !SafeCrypto.isUnlocked(targetSafeId)) {
                alert('This folder is in a locked safe. Please unlock the safe first.');
                return;
            }

            isUploading = true;
            submitBtn.disabled = true;
            cancelBtn.disabled = true;
            progressDiv.classList.remove('hidden');

            const useAiTags = autoAiTagsCheckbox.checked;
            const manualTags = tagsInput.value.trim()
                .split(',')
                .map(t => t.trim().toLowerCase())
                .filter(t => t.length > 0);

            let uploadedIds = [];

            try {
                if (uploadMode === 'folder') {
                    // Bulk folder upload
                    if (!folderFiles.length) return;
                    
                    // Check file sizes
                    const oversizedFiles = folderFiles.filter(({ file }) => file.size > MAX_FILE_SIZE);
                    if (oversizedFiles.length > 0) {
                        const maxSizeMB = (MAX_FILE_SIZE / 1024 / 1024).toFixed(0);
                        const fileNames = oversizedFiles.map(({ file }) => file.name).join(', ');
                        alert(`File(s) too large (max ${maxSizeMB}MB): ${fileNames}`);
                        throw new Error('Files too large');
                    }

                    // Check if uploading to a safe - not supported yet
                    if (targetSafeId) {
                        alert('Folder upload is not supported in safes. Please upload files individually.');
                        throw new Error('Folder upload not supported in safes');
                    }

                    progressText.textContent = `Uploading ${folderFiles.length} files...`;
                    progressFill.style.width = '30%';

                    const formData = new FormData();
                    const paths = [];

                    folderFiles.forEach(({ file, relativePath }) => {
                        formData.append('files', file);
                        paths.push(relativePath);
                    });

                    formData.append('paths', JSON.stringify(paths));
                    formData.append('folder_id', targetFolderId);

                    progressFill.style.width = '50%';
                    const resp = await csrfFetch('{{ base_url }}/upload-bulk', { method: 'POST', body: formData });

                    if (!resp.ok) {
                        // Handle 413 Content Too Large (nginx error)
                        if (resp.status === 413) {
                            throw new Error('File too large. Please increase client_max_body_size in nginx config or upload smaller files.');
                        }
                        const contentType = resp.headers.get('content-type');
                        if (contentType && contentType.includes('application/json')) {
                            const err = await resp.json();
                            throw new Error(err.detail || 'Upload failed');
                        } else {
                            const text = await resp.text();
                            console.error('Upload error response:', text.substring(0, 200));
                            throw new Error(`Upload failed: HTTP ${resp.status}`);
                        }
                    }

                    const data = await resp.json();
                    progressFill.style.width = '90%';

                    // Build result message
                    const s = data.summary;
                    let msg = `Uploaded: ${s.individual_photos} photos`;
                    if (s.albums_created > 0) {
                        msg += `, ${s.albums_created} albums (${s.photos_in_albums} photos)`;
                    }
                    if (s.failed > 0) {
                        msg += ` | ${s.failed} failed`;
                    }
                    if (s.skipped_nested > 0) {
                        msg += ` | ${s.skipped_nested} nested skipped`;
                    }
                    progressText.textContent = msg;

                    // Note: bulk upload doesn't return individual photo IDs for tagging
                    // AI tags and manual tags won't be applied to bulk uploads
                    progressFill.style.width = '100%';

                } else {
                    // Regular file upload
                    const files = selectedFiles;
                    if (!files.length) return;
                    
                    // Check file sizes
                    const oversizedFiles = files.filter(f => f.size > MAX_FILE_SIZE);
                    if (oversizedFiles.length > 0) {
                        const maxSizeMB = (MAX_FILE_SIZE / 1024 / 1024).toFixed(0);
                        const fileNames = oversizedFiles.map(f => f.name).join(', ');
                        alert(`File(s) too large (max ${maxSizeMB}MB): ${fileNames}`);
                        throw new Error('Files too large');
                    }

                    const isAlbum = albumCheckbox.checked && files.length > 1;

                    if (isAlbum) {
                        // Check if uploading to a safe - albums not supported yet
                        if (targetSafeId) {
                            alert('Albums are not supported in safes. Please upload files individually or uncheck "Create album".\n\nThe files will still be uploaded, just not as an album.');
                            throw new Error('Albums not supported in safes');
                        }

                        progressText.textContent = 'Uploading album...';
                        progressFill.style.width = '50%';

                        const formData = new FormData();
                        for (const file of files) {
                            formData.append('files', file);
                        }
                        formData.append('folder_id', targetFolderId);
                        const resp = await csrfFetch('{{ base_url }}/upload-album', { method: 'POST', body: formData });
                        if (!resp.ok) {
                            const contentType = resp.headers.get('content-type');
                            if (contentType && contentType.includes('application/json')) {
                                const err = await resp.json();
                                throw new Error(err.detail || 'Upload failed');
                            } else {
                                const text = await resp.text();
                                console.error('Upload error response:', text.substring(0, 200));
                                throw new Error(`Upload failed: HTTP ${resp.status}`);
                            }
                        }
                        const data = await resp.json();
                        uploadedIds = data.photos.map(p => p.id);
                        progressFill.style.width = '100%';
                    } else {
                        console.log('[Upload] Starting file upload, targetSafeId:', targetSafeId);
                        console.log('[Upload] SafeCrypto available:', !!window.SafeCrypto);
                        console.log('[Upload] SafeCrypto.isUnlocked:', targetSafeId ? SafeCrypto.isUnlocked(targetSafeId) : 'N/A');
                        
                        for (let i = 0; i < files.length; i++) {
                            progressText.textContent = `Uploading ${i + 1}/${files.length}...`;
                            progressFill.style.width = `${((i + 1) / files.length) * 100}%`;

                            const formData = new FormData();
                            
                            // If uploading to a safe, encrypt the file first
                            if (targetSafeId) {
                                console.log(`[Upload] File ${i+1}: Encrypting for safe ${targetSafeId}`);
                                try {
                                    const encrypted = await encryptFileForSafeUpload(files[i], targetSafeId);
                                    console.log(`[Upload] File ${i+1}: Encrypted size:`, encrypted.encryptedFile.size);
                                    // Create a new File from the encrypted blob to preserve the name
                                    const encryptedFile = new File([encrypted.encryptedFile], files[i].name, {
                                        type: 'application/octet-stream'
                                    });
                                    formData.append('file', encryptedFile);
                                    formData.append('encrypted_ck', 'safe'); // Marker for safe-encrypted files
                                    
                                    // Add encrypted thumbnail if generated
                                    console.log(`[Upload] File ${i+1}: Checking thumbnail:`, encrypted.encryptedThumbnail);
                                    if (encrypted.encryptedThumbnail) {
                                        console.log(`[Upload] File ${i+1}: Adding thumbnail, size:`, encrypted.encryptedThumbnail.size);
                                        const thumbFile = new File([encrypted.encryptedThumbnail], 'thumb.jpg.encrypted', {
                                            type: 'application/octet-stream'
                                        });
                                        formData.append('thumbnail', thumbFile);
                                        formData.append('thumb_width', encrypted.thumbWidth || 0);
                                        formData.append('thumb_height', encrypted.thumbHeight || 0);
                                    }
                                    
                                    console.log(`[Upload] File ${i+1}: FormData prepared with encrypted_ck marker`);
                                } catch (encryptErr) {
                                    console.error(`[Upload] File ${i+1}: Encryption failed:`, encryptErr);
                                    throw new Error(`Encryption failed: ${encryptErr.message}`);
                                }
                            } else {
                                console.log(`[Upload] File ${i+1}: Regular upload (no safe)`);
                                formData.append('file', files[i]);
                            }
                            
                            formData.append('folder_id', targetFolderId);
                            const resp = await csrfFetch('{{ base_url }}/upload', { method: 'POST', body: formData });
                            if (!resp.ok) {
                                // Handle 413 Content Too Large (nginx error)
                                if (resp.status === 413) {
                                    throw new Error('File too large. Please increase client_max_body_size in nginx config or upload smaller files.');
                                }
                                const contentType = resp.headers.get('content-type');
                                if (contentType && contentType.includes('application/json')) {
                                    const err = await resp.json();
                                    throw new Error(err.detail || 'Upload failed');
                                } else {
                                    const text = await resp.text();
                                    console.error('Upload error response:', text.substring(0, 200));
                                    throw new Error(`Upload failed: HTTP ${resp.status}`);
                                }
                            }
                            const data = await resp.json();
                            uploadedIds.push(data.id);
                        }
                    }

                    // Apply AI tags if requested
                    if (useAiTags && uploadedIds.length > 0) {
                        progressText.textContent = 'Generating AI tags...';
                        await csrfFetch('{{ base_url }}/api/photos/batch-ai-tags', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ photo_ids: uploadedIds })
                        });
                    }

                    // Apply manual tags if provided
                    if (manualTags.length > 0 && uploadedIds.length > 0) {
                        progressText.textContent = 'Applying tags...';
                        for (const photoId of uploadedIds) {
                            for (const tag of manualTags) {
                                await csrfFetch(`{{ base_url }}/api/photos/${photoId}/tag`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ tag: tag, category_id: 6 })
                                });
                            }
                        }
                    }

                    progressText.textContent = 'Done!';
                }

                // Close modal and refresh via SPA (no page reload)
                setTimeout(() => {
                    isUploading = false;
                    submitBtn.disabled = false;
                    cancelBtn.disabled = false;
                    closeModal();
                    // Refresh current folder content via SPA
                    if (targetFolderId) {
                        navigateToFolder(targetFolderId, false);
                    } else if (window.currentSafeId) {
                        navigateToSafe(window.currentSafeId, false);
                    } else {
                        location.reload();
                    }
                }, 500);

            } catch (err) {
                console.error('Upload error:', err);
                progressText.textContent = 'Upload failed: ' + err.message;
                isUploading = false;
                submitBtn.disabled = false;
                cancelBtn.disabled = false;
            }
        };
    </script>

    <script>
        // === Sidebar and Folder Management ===
        let folderTree = [];
        window.folderTree = folderTree; // Export for other scripts
        let editingFolderId = null;
        let userDefaultFolderId = null;
        let collapsedFolders = new Set();

        // Sidebar elements
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const folderTreeContainer = document.getElementById('folder-tree');

        // Folder modal elements
        const folderModal = document.getElementById('folder-modal');
        const folderModalTitle = document.getElementById('folder-modal-title');
        const folderNameInput = document.getElementById('folder-name-input');
        const folderParentSelect = document.getElementById('folder-parent-select');
        const folderCancelBtn = document.getElementById('folder-cancel-btn');
        const folderSubmitBtn = document.getElementById('folder-submit-btn');
        const folderModalClose = folderModal.querySelector('.close');
        const defaultFolderSection = document.getElementById('default-folder-section');
        const setDefaultFolderBtn = document.getElementById('set-default-folder-btn');

        // Mobile sidebar toggle
        function openSidebar() {
            sidebar.classList.add('open');
            sidebarOverlay.classList.remove('hidden');
            sidebarOverlay.classList.add('visible');
        }

        function closeSidebar() {
            sidebar.classList.remove('open');
            sidebarOverlay.classList.remove('visible');
            sidebarOverlay.classList.add('hidden');
        }

        sidebarToggle.onclick = () => {
            if (sidebar.classList.contains('open')) {
                closeSidebar();
            } else {
                openSidebar();
            }
        };

        // Clicking/touching overlay closes sidebar and blocks other interactions
        sidebarOverlay.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeSidebar();
        };

        sidebarOverlay.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });

        sidebarOverlay.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeSidebar();
        }, { passive: false });

        // Mobile swipe to close sidebar
        let sidebarTouchStartX = 0;
        let sidebarTouchStartY = 0;
        const sidebarSwipeThreshold = 50;

        sidebar.addEventListener('touchstart', (e) => {
            sidebarTouchStartX = e.changedTouches[0].screenX;
            sidebarTouchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        sidebar.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const deltaX = touchEndX - sidebarTouchStartX;
            const deltaY = Math.abs(touchEndY - sidebarTouchStartY);

            // Swipe left to close (sidebar is on the left side)
            if (deltaX < -sidebarSwipeThreshold && deltaY < sidebarSwipeThreshold) {
                closeSidebar();
            }
        }, { passive: true });

        // Load folder tree (with cache for instant display)
        async function loadFolderTree() {
            // Show cached version immediately if available
            const cached = sessionStorage.getItem('folderTreeCache');
            if (cached) {
                try {
                    folderTree = JSON.parse(cached);
                    window.folderTree = folderTree;
                    renderFolderTree();
                    updateParentSelect();
                } catch (e) {
                    // Invalid cache, ignore
                }
            }

            // Fetch fresh data
            try {
                const resp = await fetch('{{ base_url }}/api/folders');
                const freshData = await resp.json();

                // Update cache
                sessionStorage.setItem('folderTreeCache', JSON.stringify(freshData));

                // Only re-render if data changed
                if (JSON.stringify(freshData) !== JSON.stringify(folderTree)) {
                    folderTree = freshData;
                    window.folderTree = folderTree;
                    renderFolderTree();
                    updateParentSelect();
                }
            } catch (err) {
                console.error('Failed to load folders:', err);
            }
        }

        // Load user's default folder
        async function loadDefaultFolder() {
            try {
                const resp = await fetch('{{ base_url }}/api/folders/user/default');
                const data = await resp.json();
                userDefaultFolderId = data.default_folder_id;
            } catch (err) {
                console.error('Failed to load default folder:', err);
            }
        }

        // Load user's collapsed folders (with cache)
        async function loadCollapsedFolders() {
            // Show cached version immediately if available
            const cached = sessionStorage.getItem('collapsedFoldersCache');
            if (cached) {
                try {
                    collapsedFolders = new Set(JSON.parse(cached));
                } catch (e) {
                    // Invalid cache, ignore
                }
            }

            // Fetch fresh data
            try {
                const resp = await fetch('{{ base_url }}/api/folders/user/collapsed');
                const data = await resp.json();
                const freshCollapsed = data.collapsed_folders || [];

                // Update cache
                sessionStorage.setItem('collapsedFoldersCache', JSON.stringify(freshCollapsed));

                // Only re-render if data changed
                const oldCollapsed = [...collapsedFolders].sort().join(',');
                const newCollapsed = [...freshCollapsed].sort().join(',');
                if (oldCollapsed !== newCollapsed) {
                    collapsedFolders = new Set(freshCollapsed);
                    renderFolderTree();
                }
            } catch (err) {
                console.error('Failed to load collapsed folders:', err);
            }
        }

        // Update collapsed folders cache
        function updateCollapsedCache() {
            sessionStorage.setItem('collapsedFoldersCache', JSON.stringify([...collapsedFolders]));
        }

        // Toggle folder collapse state
        async function toggleFolderCollapse(folderId, event) {
            event.stopPropagation();

            // Optimistic update
            const wasCollapsed = collapsedFolders.has(folderId);
            if (wasCollapsed) {
                collapsedFolders.delete(folderId);
            } else {
                collapsedFolders.add(folderId);
            }
            renderFolderTree();
            updateCollapsedCache();

            // Persist to server
            try {
                await csrfFetch(`{{ base_url }}/api/folders/${folderId}/toggle-collapse`, {
                    method: 'POST'
                });
            } catch (err) {
                console.error('Failed to toggle folder collapse:', err);
                // Revert on error
                if (wasCollapsed) {
                    collapsedFolders.add(folderId);
                } else {
                    collapsedFolders.delete(folderId);
                }
                renderFolderTree();
                updateCollapsedCache();
            }
        }

        // Check if folder has children
        function folderHasChildren(folderId) {
            return folderTree.some(f => f.parent_id === folderId);
        }

        // Render folder tree recursively
        function renderFolderTree() {
            const myFolders = folderTree.filter(f => f.permission === 'owner' && !f.safe_id);
            const safeFolders = folderTree.filter(f => f.permission === 'owner' && f.safe_id);
            const sharedFolders = folderTree.filter(f => f.permission !== 'owner');

            let html = '';

            // My Folders section (regular folders)
            html += '<div class="folder-section">';
            html += '<div class="folder-section-header">My Folders</div>';
            if (myFolders.length > 0) {
                html += buildTreeHTML(null, 0, myFolders);
            }
            // Add folder button at the end
            html += `
                <div class="folder-item-wrapper">
                    <span class="folder-expand-placeholder"></span>
                    <div class="folder-item add-folder-item" onclick="openCreateFolder()">
                        <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                            <line x1="12" y1="11" x2="12" y2="17"/>
                            <line x1="9" y1="14" x2="15" y2="14"/>
                        </svg>
                        <span class="folder-name">add folder</span>
                    </div>
                </div>
            `;
            html += '</div>';

            // Safes section
            if (userSafes.length > 0) {
                html += '<div class="folder-section">';
                html += '<div class="folder-section-header">Safes</div>';
                
                userSafes.forEach(safe => {
                    const isUnlocked = safe.is_unlocked;
                    const safeFoldersList = safeFolders.filter(f => f.safe_id === safe.id);
                    
                    // Safe header - click to unlock if locked, navigate to safe if unlocked
                    const safeClickHandler = isUnlocked 
                        ? `navigateToSafe('${safe.id}')`
                        : `openSafeUnlock('${safe.id}', '${escapeHtml(safe.name)}', '${safe.unlock_type}')`;
                    
                    html += `
                        <div class="folder-item-wrapper">
                            <span class="folder-expand-placeholder"></span>
                            <div class="folder-item safe-item ${isUnlocked ? 'unlocked' : 'locked'}" 
                                 data-safe-id="${safe.id}"
                                 onclick="${safeClickHandler}">
                                <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    ${isUnlocked ? `
                                        <rect x="5" y="11" width="14" height="10" rx="2"/>
                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                    ` : `
                                        <rect x="5" y="11" width="14" height="10" rx="2"/>
                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                        <circle cx="12" cy="16" r="1" fill="currentColor"/>
                                    `}
                                </svg>
                                <span class="folder-name">${escapeHtml(safe.name)}</span>
                                <span class="folder-count">${safe.photo_count || 0}</span>
                            </div>
                        </div>
                    `;
                    
                    // Folders inside safe (only if unlocked)
                    if (isUnlocked) {
                        if (safeFoldersList.length > 0) {
                            html += buildSafeTreeHTML(safe.id, 1, safeFoldersList, null);
                        }
                        // Add "add folder" button at the end of safe folder list
                        html += `
                            <div class="folder-item-wrapper safe-folder" style="padding-left: 16px">
                                <span class="folder-expand-placeholder"></span>
                                <div class="folder-item add-folder-item" onclick="openCreateFolderInSafe('${safe.id}')">
                                    <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                                        <line x1="12" y1="11" x2="12" y2="17"></line>
                                        <line x1="9" y1="14" x2="15" y2="14"></line>
                                    </svg>
                                    <span class="folder-name">add folder</span>
                                </div>
                            </div>
                        `;
                    }
                });
                
                // Add safe button
                html += `
                    <div class="folder-item-wrapper">
                        <span class="folder-expand-placeholder"></span>
                        <div class="folder-item add-folder-item" onclick="openCreateSafe()">
                            <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="5" y="11" width="14" height="10" rx="2"/>
                                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                <line x1="12" y1="14" x2="12" y2="17"/>
                                <line x1="9" y1="15.5" x2="15" y2="15.5"/>
                            </svg>
                            <span class="folder-name">create safe</span>
                        </div>
                    </div>
                `;
                
                html += '</div>';
            } else {
                // Show create safe button even if no safes exist
                html += '<div class="folder-section">';
                html += '<div class="folder-section-header">Safes</div>';
                html += `
                    <div class="folder-item-wrapper">
                        <span class="folder-expand-placeholder"></span>
                        <div class="folder-item add-folder-item" onclick="openCreateSafe()">
                            <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="5" y="11" width="14" height="10" rx="2"/>
                                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                                <line x1="12" y1="14" x2="12" y2="17"/>
                                <line x1="9" y1="15.5" x2="15" y2="15.5"/>
                            </svg>
                            <span class="folder-name">create safe</span>
                        </div>
                    </div>
                `;
                html += '</div>';
            }

            // Shared with me section
            if (sharedFolders.length > 0) {
                html += '<div class="folder-section">';
                html += '<div class="folder-section-header">Shared with me</div>';
                html += sharedFolders.map(folder => buildFolderItem(folder, 0, false)).join('');
                html += '</div>';
            }

            folderTreeContainer.innerHTML = html;
        }

        // Build tree for folders inside a safe (same algorithm as buildTreeHTML)
        function buildSafeTreeHTML(safeId, level, folders, parentId = null) {
            // If parent is collapsed, don't render children
            if (parentId && collapsedFolders.has(parentId)) {
                return '';
            }

            const children = folders.filter(f => f.parent_id === parentId);
            if (children.length === 0) return '';

            return children.map(folder => {
                const isActive = folder.id === window.currentFolderId;
                const hasChildren = folders.some(f => f.parent_id === folder.id);
                const isCollapsed = collapsedFolders.has(folder.id);
                const photoCount = folder.photo_count || 0;
                
                const expandArrow = hasChildren ? `
                    <button class="folder-expand-btn ${isCollapsed ? 'collapsed' : ''}"
                            onclick="toggleFolderCollapse('${folder.id}', event)"
                            title="${isCollapsed ? 'Expand' : 'Collapse'}">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"/>
                        </svg>
                    </button>
                ` : '<span class="folder-expand-placeholder"></span>';
                
                return `
                    <div class="folder-item-wrapper safe-folder" style="padding-left: ${level * 16}px">
                        ${expandArrow}
                        <div class="folder-item private ${isActive ? 'active' : ''}"
                             data-folder-id="${folder.id}"
                             onclick="return navigateToFolder('${folder.id}', true, event);">
                            <svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                            </svg>
                            <span class="folder-name">${escapeHtml(folder.name)}</span>
                            <span class="folder-count">${photoCount}</span>
                        </div>
                    </div>
                ` + buildSafeTreeHTML(safeId, level + 1, folders, folder.id);
            }).join('');
        }

        function buildTreeHTML(parentId, level, folders = folderTree) {
            // If parent is collapsed, don't render children
            if (parentId && collapsedFolders.has(parentId)) {
                return '';
            }

            const children = folders.filter(f => f.parent_id === parentId && f.permission === 'owner');
            if (children.length === 0) return '';

            return children.map(folder => buildFolderItem(folder, level, true) + buildTreeHTML(folder.id, level + 1, folders)).join('');
        }

        function buildFolderItem(folder, level, isOwn) {
            const isActive = folder.id === window.currentFolderId;
            const permission = folder.permission;
            const shareStatus = folder.share_status;
            const photoCount = folder.photo_count || 0;

            // Icon and class based on ownership and share status
            let folderIcon;
            let folderClass = '';

            if (permission === 'owner') {
                // Own folder - show share status
                if (shareStatus === 'has_editors') {
                    // Shared with editors (orange)
                    folderClass = 'shared-editors';
                    folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                        <path d="M15 12l-3 3m0 0l-3-3m3 3V9"/>
                    </svg>`;
                } else if (shareStatus === 'has_viewers') {
                    // Shared with viewers only (green)
                    folderClass = 'shared-viewers';
                    folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                        <circle cx="12" cy="13" r="2"/><path d="M18 13c-1.5 2-3.5 3-6 3s-4.5-1-6-3c1.5-2 3.5-3 6-3s4.5 1 6 3z"/>
                    </svg>`;
                } else {
                    // Private folder (default gray with lock)
                    folderClass = 'private';
                    folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                        <rect x="9" y="11" width="6" height="5" rx="1"/><path d="M10 11V9a2 2 0 1 1 4 0v2"/>
                    </svg>`;
                }
            } else if (permission === 'editor') {
                // Shared folder where I'm editor (orange border)
                folderClass = 'incoming-editor';
                folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    <path d="M12 16V9m0 0l3 3m-3-3l-3 3"/>
                </svg>`;
            } else {
                // Shared folder where I'm viewer (green border)
                folderClass = 'incoming-viewer';
                folderIcon = `<svg class="folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    <circle cx="12" cy="13" r="2"/><path d="M18 13c-1.5 2-3.5 3-6 3s-4.5-1-6-3c1.5-2 3.5-3 6-3s4.5 1 6 3z"/>
                </svg>`;
            }

            const ownerInfo = !isOwn && folder.owner_name ? `<span class="folder-owner">${escapeHtml(folder.owner_name)}</span>` : '';

            // Determine if user can edit this folder (owner or editor)
            const canEdit = permission === 'owner' || permission === 'editor';

            // Check if folder has children and collapse state
            const hasChildren = folderHasChildren(folder.id);
            const isCollapsed = collapsedFolders.has(folder.id);

            // Expand/collapse arrow for folders with children
            const expandArrow = hasChildren ? `
                <button class="folder-expand-btn ${isCollapsed ? 'collapsed' : ''}"
                        onclick="toggleFolderCollapse('${folder.id}', event)"
                        title="${isCollapsed ? 'Expand' : 'Collapse'}">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"/>
                    </svg>
                </button>
            ` : '<span class="folder-expand-placeholder"></span>';

            return `
                <div class="folder-item-wrapper" style="padding-left: ${level * 16}px">
                    ${expandArrow}
                    <div class="folder-item ${folderClass} ${isActive ? 'active' : ''}"
                         data-folder-id="${folder.id}"
                         data-can-edit="${canEdit}"
                         onclick="return navigateToFolder('${folder.id}', true, event);">
                        ${folderIcon}
                        <span class="folder-name">${escapeHtml(folder.name)}</span>
                        ${ownerInfo}
                        <span class="folder-count">${photoCount}</span>
                    </div>
                </div>
            `;
        }

        // navigateToFolder and renderFolderContent moved to navigation.js
        
        // Navigate to safe (show all photos in safe, allow upload to safe root)
        window.navigateToSafe = async function(safeId, pushState = true) {
            console.log('[SPA] Navigating to safe:', safeId);
            
            // Find safe info
            const safe = userSafes.find(s => s.id === safeId);
            if (!safe) {
                console.error('[navigateToSafe] Safe not found:', safeId);
                return;
            }
            
            // Check if safe is unlocked
            if (!SafeCrypto.isUnlocked(safeId)) {
                console.log('[navigateToSafe] Safe is locked, opening unlock modal');
                openSafeUnlock(safeId, safe.name, safe.unlock_type);
                return;
            }
            
            // Smooth transition
            const gallery = document.getElementById('gallery');
            if (gallery) {
                gallery.style.opacity = '0.5';
            }
            
            try {
                // Find ALL root folders for this safe
                console.log('[navigateToSafe] folderTree:', folderTree.map(f => ({id: f.id, name: f.name, safe_id: f.safe_id, parent_id: f.parent_id})));
                const rootFolders = folderTree.filter(f => f.safe_id === safeId && !f.parent_id);
                console.log('[navigateToSafe] rootFolders:', rootFolders.map(f => f.name));
                
                // Find ALL subfolders inside root folders
                const allSubfolders = folderTree.filter(f => f.safe_id === safeId && f.parent_id && rootFolders.some(rf => rf.id === f.parent_id));
                console.log('[navigateToSafe] allSubfolders:', allSubfolders.map(f => f.name));
                
                // Use first root folder as primary (for uploads), but we'll show content from all
                const primaryFolderId = rootFolders.length > 0 ? rootFolders[0].id : null;
                
                // Update URL
                if (pushState) {
                    history.pushState({ safeId: safeId }, '', `{{ base_url }}/?safe_id=${safeId}`);
                }
                
                // Set current state - we're in safe
                window.currentFolderId = primaryFolderId;
                window.currentSafeId = safeId;
                
                // Safe works like a regular folder - show its root content (empty) and subfolders
                if (rootFolders.length > 0) {
                    console.log('[navigateToSafe] Safe has', rootFolders.length, 'root folders, rendering as folder');
                    
                    // Create fake folder data for the safe root
                    const safeAsFolder = {
                        folder: {
                            id: safeId,
                            name: safe.name,
                            user_id: safe.user_id,
                            permission: 'owner' // Safe owner always has full access
                        },
                        // Root of safe has no items (they are in subfolders)
                        items: [],
                        albums: [],
                        photos: [],
                        subfolders: rootFolders, // These will be shown as subfolders
                        breadcrumbs: [
                            { id: safeId, name: safe.name }
                        ],
                        sort: 'uploaded'
                    };
                    
                    console.log('[navigateToSafe] Rendering safe as folder with', rootFolders.length, 'subfolders');
                    renderFolderContent(safeAsFolder);
                } else {
                    // No folders in safe yet - show empty state
                    console.log('[navigateToSafe] No root folder, showing empty state');
                    renderSafeRootContent(safe);
                }
                
                // Highlight safe in sidebar (not a specific folder)
                document.querySelectorAll('.folder-item').forEach(item => item.classList.remove('active'));
                const safeItem = document.querySelector(`.folder-item.safe-item[data-safe-id="${safeId}"]`);
                if (safeItem) safeItem.classList.add('active');
                
                loadSafeThumbnails();
                
                // Update folder header for safe
                const folderHeader = document.querySelector('.folder-header');
                const folderBreadcrumbs = document.getElementById('folder-breadcrumbs');
                
                if (folderHeader) {
                    folderHeader.style.display = 'flex';
                    const h2 = folderHeader.querySelector('h2');
                    if (h2) h2.textContent = safe.name;
                    
                    // Show upload button for safe
                    const uploadBtn = folderHeader.querySelector('#folder-upload-btn');
                    if (uploadBtn) uploadBtn.style.display = '';
                    
                    // Update buttons for safe: hide share, show edit for safe, hide sort
                    const shareBtn = folderHeader.querySelector('button[title="Share"]');
                    const editBtn = folderHeader.querySelector('button[title^="Edit"]');
                    const sortBtn = folderHeader.querySelector('#sort-btn');
                    if (shareBtn) shareBtn.style.display = 'none';
                    if (editBtn) {
                        editBtn.style.display = '';
                        editBtn.setAttribute('onclick', `openEditSafe('${safeId}')`);
                        editBtn.setAttribute('title', 'Edit safe');
                    }
                    if (sortBtn) sortBtn.style.display = 'none';
                }
                
                if (folderBreadcrumbs) {
                    folderBreadcrumbs.innerHTML = `
                        <a href="{{ base_url }}/" onclick="event.preventDefault(); navigateToDefaultFolder(); return false;">Home</a>
                        <span class="separator">/</span>
                        <span>${escapeHtml(safe.name)}</span>
                    `;
                    folderBreadcrumbs.style.display = '';
                }
                
            } catch (err) {
                console.error('[navigateToSafe] Failed:', err);
                alert('Failed to load safe: ' + err.message);
            }
        }
        
        // Render safe content similar to regular gallery with subfolders section
        function renderSafeContent(data, safe, subfolders) {
            console.log('[renderSafeContent] Rendering safe:', safe.name, 'subfolders:', subfolders?.length, 'items:', data.items?.length);
            console.log('[renderSafeContent] Items types:', data.items?.map(i => i.type));
            
            const gallery = document.getElementById('gallery');
            
            if (!gallery) {
                console.error('[renderSafeContent] Gallery element not found!');
                return;
            }
            
            document.title = safe.name + ' - Synth Gallery';
            
            // Build subfolders section using provided subfolders list
            let subfoldersHtml = '';
            if (subfolders && subfolders.length > 0) {
                subfoldersHtml = `
                    <div class="subfolders-section">
                        <div class="subfolders-grid">
                            ${subfolders.map(folder => `
                                <a href="{{ base_url }}/?folder_id=${folder.id}" class="subfolder-tile" data-folder-id="${folder.id}" onclick="event.preventDefault(); event.stopPropagation(); navigateToFolder('${folder.id}'); return false;">
                                    <svg class="subfolder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                                    </svg>
                                    <span class="subfolder-name">${escapeHtml(folder.name)}</span>
                                    <span class="subfolder-count">${folder.photo_count || 0}</span>
                                </a>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Filter only photos and albums for gallery (exclude folders)
            const galleryItems = (data.items || []).filter(item => item.type === 'photo' || item.type === 'album');
            console.log('[renderSafeContent] Gallery items after filter:', galleryItems.length);
            
            // Build gallery content (photos and albums from root folder)
            let galleryHtml = '<div class="gallery" id="gallery" style="opacity: 0; transition: opacity 0.15s;">';
            
            if (galleryItems.length > 0) {
                galleryItems.forEach(item => {
                    if (item.type === 'album') {
                        // Album rendering
                        const album = item.data;
                        const coverId = album.cover_photo_id || album.effective_cover_photo_id;
                        galleryHtml += `
                            <div class="gallery-item album-item" data-album-id="${album.id}" data-item-type="album">
                                <div class="gallery-link" onclick="openAlbum('${album.id}')">
                                    ${coverId ? `
                                        <div class="gallery-placeholder"></div>
                                        <img src="{{ base_url }}/thumbnails/${coverId}.jpg" alt="${escapeHtml(album.name)}" loading="lazy" onload="this.previousElementSibling.style.display='none'; this.style.opacity='1';" style="opacity: 0;">
                                    ` : `
                                        <div class="album-placeholder"><span>Empty Album</span></div>
                                    `}
                                    <div class="album-badge">
                                        <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                                            <rect x="3" y="3" width="7" height="7" rx="1"/>
                                            <rect x="14" y="3" width="7" height="7" rx="1"/>
                                            <rect x="3" y="14" width="7" height="7" rx="1"/>
                                            <rect x="14" y="14" width="7" height="7" rx="1"/>
                                        </svg>
                                        <span>${album.photo_count || 0}</span>
                                    </div>
                                </div>
                                <div class="select-indicator" title="Select">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                        <polyline points="20 6 9 17 4 12"></polyline>
                                    </svg>
                                </div>
                            </div>
                        `;
                    } else if (item.type === 'photo') {
                        // Photo rendering
                        const photo = item.data;
                        const safeId = photo.safe_id;
                        const mediaType = photo.media_type || 'image';
                        
                        if (safeId) {
                            // Safe photo with client-side thumbnail
                            galleryHtml += `
                                <div class="gallery-item" data-photo-id="${photo.id}" data-item-type="photo" data-media-type="${mediaType}" data-safe-id="${safeId}">
                                    <div class="gallery-link" onclick="openPhoto('${photo.id}')">
                                        <div class="gallery-placeholder"></div>
                                        <img data-safe-thumbnail="${photo.id}" data-safe-id="${safeId}" alt="${escapeHtml(photo.original_name)}" loading="lazy" style="opacity: 0;">
                                        ${mediaType === 'video' ? `
                                            <div class="video-badge">
                                                <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                                                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                                                </svg>
                                            </div>
                                        ` : ''}
                                    </div>
                                    <div class="select-indicator" title="Select">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                            <polyline points="20 6 9 17 4 12"></polyline>
                                        </svg>
                                    </div>
                                </div>
                            `;
                        } else {
                            // Regular photo
                            galleryHtml += `
                                <div class="gallery-item" data-photo-id="${photo.id}" data-item-type="photo" data-media-type="${mediaType}">
                                    <div class="gallery-link" onclick="openPhoto('${photo.id}')">
                                        <div class="gallery-placeholder"></div>
                                        <img src="{{ base_url }}/thumbnails/${photo.id}.jpg" alt="${escapeHtml(photo.original_name || '')}" loading="lazy" onload="this.previousElementSibling.style.display='none'; this.style.opacity='1';" style="opacity: 0;">
                                        ${mediaType === 'video' ? `
                                            <div class="video-badge">
                                                <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                                                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                                                </svg>
                                            </div>
                                        ` : ''}
                                    </div>
                                    <div class="select-indicator" title="Select">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                            <polyline points="20 6 9 17 4 12"></polyline>
                                        </svg>
                                    </div>
                                </div>
                            `;
                        }
                    }
                });
            } else {
                galleryHtml += `
                    <div class="empty-state">
                        <p>No photos yet</p>
                        <p>Click "Upload" to add your first photos</p>
                    </div>
                `;
            }
            
            galleryHtml += '</div>';
            
            console.log('[renderSafeContent] subfoldersHtml length:', subfoldersHtml.length);
            console.log('[renderSafeContent] galleryHtml length:', galleryHtml.length);
            console.log('[renderSafeContent] gallery exists before insert:', !!document.getElementById('gallery'));
            
            // Insert subfolders before gallery and replace gallery content
            gallery.insertAdjacentHTML('beforebegin', subfoldersHtml);
            console.log('[renderSafeContent] After insertAdjacentHTML, gallery exists:', !!document.getElementById('gallery'));
            
            gallery.outerHTML = galleryHtml;
            console.log('[renderSafeContent] After outerHTML, gallery exists:', !!document.getElementById('gallery'));
            
            // Restore opacity
            setTimeout(() => {
                const newGallery = document.getElementById('gallery');
                if (newGallery) newGallery.style.opacity = '1';
            }, 50);
            
            // Load safe thumbnails
            if (typeof loadSafeThumbnails === 'function') {
                loadSafeThumbnails();
            }
            
            // Initialize masonry if available
            if (typeof window.rebuildMasonry === 'function') {
                setTimeout(() => window.rebuildMasonry(true), 100);
            }
        }
        
        // Render safe root content (when safe has no folders yet)
        function renderSafeRootContent(safe) {
            const gallery = document.getElementById('gallery');
            if (!gallery) return;
            
            gallery.innerHTML = `
                <div class="empty-state">
                    <p>Safe "${escapeHtml(safe.name)}" is empty</p>
                    <p>Create a folder or upload photos directly to the safe</p>
                </div>
            `;
            document.title = safe.name + ' - Synth Gallery';
            gallery.style.opacity = '1';
        }
        
        
        // Load safe thumbnails client-side (E2E decryption)
        window.loadSafeThumbnails = async function() {
            const safeImages = document.querySelectorAll('img[data-safe-thumbnail]');
            if (safeImages.length === 0) return;
            
            // Placeholder SVG for locked/missing thumbnails
            const placeholderSvg = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%23666" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2" fill="%23333"/><circle cx="8.5" cy="8.5" r="1.5" fill="%23666"/><path d="M21 15l-5-5L5 21" stroke="%23666"/><path d="M7 11l3-3 2 2 4-4" stroke="%23666"/></svg>';
            
            for (const img of safeImages) {
                const photoId = img.dataset.safeThumbnail;
                const safeId = img.dataset.safeId;
                
                if (!photoId || !safeId) continue;
                
                // Check if safe is unlocked
                if (!SafeCrypto.isUnlocked(safeId)) {
                    // Show locked placeholder
                    img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%23999" stroke-width="2"><rect x="5" y="11" width="14" height="10" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>';
                    img.style.opacity = '1';
                    img.previousElementSibling.style.display = 'none';
                    continue;
                }
                
                try {
                    // Fetch encrypted thumbnail
                    const resp = await fetch(`{{ base_url }}/api/safe-files/photos/${photoId}/thumbnail`);
                    
                    // Check if thumbnail needs regeneration (202 status with X-Regenerate-Thumbnail header)
                    if (resp.status === 202 && resp.headers.get('X-Regenerate-Thumbnail') === 'true') {
                        console.log(`[LoadSafeThumbnails] Thumbnail missing for ${photoId}, regenerating...`);
                        
                        // Show loading state
                        img.style.opacity = '0.5';
                        
                        // Regenerate thumbnail
                        const regeneratedBlob = await regenerateSafeThumbnail(photoId, safeId);
                        
                        if (!regeneratedBlob) {
                            console.warn(`[LoadSafeThumbnails] Failed to regenerate thumbnail for ${photoId}`);
                            img.src = placeholderSvg;
                            img.style.opacity = '1';
                            img.previousElementSibling.style.display = 'none';
                            if (window.onGalleryImageLoad) {
                                window.onGalleryImageLoad(img);
                            }
                            continue;
                        }
                        
                        // Decrypt and display the regenerated thumbnail
                        const decryptedBlob = await SafeCrypto.decryptFileFromSafe(regeneratedBlob, safeId, 'image/jpeg');
                        const url = URL.createObjectURL(decryptedBlob);
                        img.src = url;
                        
                        img.onload = () => {
                            img.previousElementSibling.style.display = 'none';
                            img.style.opacity = '1';
                            if (window.onGalleryImageLoad) {
                                window.onGalleryImageLoad(img);
                            }
                        };
                        
                        img.onerror = () => {
                            img.src = placeholderSvg;
                            img.style.opacity = '1';
                            img.previousElementSibling.style.display = 'none';
                            if (window.onGalleryImageLoad) {
                                window.onGalleryImageLoad(img);
                            }
                        };
                        continue;
                    }
                    
                    if (!resp.ok) {
                        console.warn(`Failed to load thumbnail for ${photoId}:`, resp.status);
                        // Show placeholder for missing thumbnail (404 or other error)
                        img.src = placeholderSvg;
                        img.style.opacity = '1';
                        img.previousElementSibling.style.display = 'none';
                        if (window.onGalleryImageLoad) {
                            window.onGalleryImageLoad(img);
                        }
                        continue;
                    }
                    
                    // Decrypt thumbnail
                    const encryptedBlob = await resp.blob();
                    const decryptedBlob = await SafeCrypto.decryptFileFromSafe(encryptedBlob, safeId, 'image/jpeg');
                    
                    // Create object URL
                    const url = URL.createObjectURL(decryptedBlob);
                    img.src = url;
                    
                    // Handle load
                    img.onload = () => {
                        img.previousElementSibling.style.display = 'none';
                        img.style.opacity = '1';
                        if (window.onGalleryImageLoad) {
                            window.onGalleryImageLoad(img);
                        }
                    };
                    
                    img.onerror = () => {
                        console.error(`Failed to load decrypted thumbnail for ${photoId}`);
                        // Show placeholder on error
                        img.src = placeholderSvg;
                        img.style.opacity = '1';
                        img.previousElementSibling.style.display = 'none';
                        if (window.onGalleryImageLoad) {
                            window.onGalleryImageLoad(img);
                        }
                    };
                    
                } catch (err) {
                    console.error(`Error loading safe thumbnail for ${photoId}:`, err);
                    // Show placeholder on error
                    img.src = placeholderSvg;
                    img.style.opacity = '1';
                    img.previousElementSibling.style.display = 'none';
                    if (window.onGalleryImageLoad) {
                        window.onGalleryImageLoad(img);
                    }
                }
            }
        }
        
        // Update sidebar active state
        function updateSidebarActiveState(folderId) {
            document.querySelectorAll('.folder-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.folderId === folderId) {
                    item.classList.add('active');
                }
            });
        }
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', (event) => {
            console.log('[SPA] Popstate:', event.state);
            if (event.state && event.state.folderId) {
                navigateToFolder(event.state.folderId, false);
            } else {
                // Reload page if no state (e.g., initial load)
                window.location.reload();
            }
        });
        
        // Track current sort - initialize from active button or default
        let currentSort = 'uploaded';
        const activeSortBtn = document.querySelector('.sort-option.active');
        if (activeSortBtn) {
            currentSort = activeSortBtn.dataset.sort || 'uploaded';
        }
        
        // Navigate to default folder
        async function navigateToDefaultFolder() {
            // Get default folder ID from server
            try {
                const resp = await fetch('{{ base_url }}/api/user/default-folder');
                if (resp.ok) {
                    const data = await resp.json();
                    if (data.folder_id) {
                        navigateToFolder(data.folder_id);
                        return;
                    }
                }
            } catch (e) {
                console.error('Failed to get default folder:', e);
            }
            // Fallback: reload page
            window.location.href = '{{ base_url }}/';
        }

        // Update parent folder select options
        function updateParentSelect() {
            folderParentSelect.innerHTML = '<option value="">Root level</option>';
            folderTree.forEach(folder => {
                // Only show owned folders as parent options
                if (folder.permission !== 'owner') return;
                // Don't show current folder as parent option when editing
                if (editingFolderId && folder.id === editingFolderId) return;
                const opt = document.createElement('option');
                opt.value = folder.id;
                opt.textContent = folder.name;
                folderParentSelect.appendChild(opt);
            });
        }

        // Folder modal elements for delete
        const deleteFolderSection = document.getElementById('delete-folder-section');
        const deleteFolderBtn = document.getElementById('delete-folder-btn');

        // Folder modal functions
        function openCreateFolder() {
            editingFolderId = null;
            folderModalTitle.textContent = 'Create Folder';
            folderSubmitBtn.textContent = 'Create';
            folderNameInput.value = '';
            folderParentSelect.value = window.currentFolderId || '';
            updateParentSelect();
            // Hide sections only shown when editing
            defaultFolderSection.classList.add('hidden');
            deleteFolderSection.classList.add('hidden');
            folderModal.classList.remove('hidden');
            folderNameInput.focus();
        }

        function openEditFolder(folderId) {
            const folder = folderTree.find(f => f.id === folderId);
            if (!folder) return;

            editingFolderId = folderId;
            folderModalTitle.textContent = 'Edit Folder';
            folderSubmitBtn.textContent = 'Save';
            folderNameInput.value = folder.name;
            folderParentSelect.value = folder.parent_id || '';
            updateParentSelect();

            // Show default folder section and update button state
            defaultFolderSection.classList.remove('hidden');
            const isCurrentDefault = userDefaultFolderId === folderId;
            if (isCurrentDefault) {
                setDefaultFolderBtn.textContent = 'This is your default folder';
                setDefaultFolderBtn.disabled = true;
            } else {
                setDefaultFolderBtn.textContent = 'Set as default folder';
                setDefaultFolderBtn.disabled = false;
            }

            // Show delete folder section
            deleteFolderSection.classList.remove('hidden');

            folderModal.classList.remove('hidden');
            folderNameInput.focus();
        }

        function closeFolderModal() {
            folderModal.classList.add('hidden');
            editingFolderId = null;
        }

        folderCancelBtn.onclick = closeFolderModal;
        folderModalClose.onclick = closeFolderModal;
        folderModal.onclick = (e) => {
            if (e.target === folderModal) closeFolderModal();
        };

        // Create or update folder
        folderSubmitBtn.onclick = async () => {
            const name = folderNameInput.value.trim();
            if (!name) {
                alert('Please enter a folder name');
                return;
            }

            const parentId = folderParentSelect.value || null;

            try {
                if (editingFolderId) {
                    // Update existing folder
                    await csrfFetch(`{{ base_url }}/api/folders/${editingFolderId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name })
                    });
                } else {
                    // Create new folder
                    await csrfFetch('{{ base_url }}/api/folders', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, parent_id: parentId })
                    });
                }
                closeFolderModal();
                loadFolderTree();
            } catch (err) {
                console.error('Folder operation failed:', err);
                alert('Operation failed');
            }
        };

        // Set folder as default
        setDefaultFolderBtn.onclick = async () => {
            if (!editingFolderId) return;

            setDefaultFolderBtn.disabled = true;
            setDefaultFolderBtn.textContent = 'Setting...';

            try {
                await csrfFetch(`{{ base_url }}/api/folders/${editingFolderId}/set-default`, {
                    method: 'PUT'
                });
                userDefaultFolderId = editingFolderId;
                setDefaultFolderBtn.textContent = 'This is your default folder';
            } catch (err) {
                console.error('Failed to set default folder:', err);
                setDefaultFolderBtn.textContent = 'Set as default folder';
                setDefaultFolderBtn.disabled = false;
                alert('Failed to set default folder');
            }
        };

        // Delete folder
        async function deleteFolder(folderId) {
            const folder = folderTree.find(f => f.id === folderId);
            if (!folder) return;

            if (!confirm(`Delete folder "${folder.name}" and all its contents?`)) return;

            try {
                await csrfFetch(`{{ base_url }}/api/folders/${folderId}`, { method: 'DELETE' });
                closeFolderModal();
                
                // Always refresh folder tree
                loadFolderTree();
                
                if (folderId === window.currentFolderId) {
                    // Navigate to parent or root using SPA navigation
                    if (folder.parent_id) {
                        navigateToFolder(folder.parent_id, true);
                    } else {
                        navigateToDefaultFolder();
                    }
                }
                // If deleted folder is not current, tree update is enough
            } catch (err) {
                console.error('Delete failed:', err);
                alert('Delete failed');
            }
        }

        // Delete folder button in modal
        deleteFolderBtn.onclick = () => {
            if (editingFolderId) {
                deleteFolder(editingFolderId);
            }
        };

        // === Share Modal ===
        let shareModalFolderId = null;
        let selectedUserId = null;
        let searchTimeout = null;

        function openShareModal(folderId) {
            shareModalFolderId = folderId;
            document.getElementById('share-modal').classList.remove('hidden');
            document.getElementById('user-search-input').value = '';
            document.getElementById('user-search-results').classList.add('hidden');
            document.getElementById('add-permission-form').classList.add('hidden');
            loadPermissions();
        }

        function closeShareModal() {
            document.getElementById('share-modal').classList.add('hidden');
            shareModalFolderId = null;
            selectedUserId = null;
        }

        // Close share modal on Escape
        document.addEventListener('keydown', (e) => {
            const shareModal = document.getElementById('share-modal');
            if (e.key === 'Escape' && shareModal && !shareModal.classList.contains('hidden')) {
                e.preventDefault();
                closeShareModal();
            }
        });

        async function loadPermissions() {
            if (!shareModalFolderId) return;

            try {
                const resp = await fetch(`{{ base_url }}/api/folders/${shareModalFolderId}/permissions`);
                const data = await resp.json();
                renderPermissions(data.permissions || []);
            } catch (err) {
                console.error('Failed to load permissions:', err);
            }
        }

        function renderPermissions(permissions) {
            const container = document.getElementById('permissions-list');

            if (permissions.length === 0) {
                container.innerHTML = '<p class="no-permissions">No one else has access</p>';
                return;
            }

            container.innerHTML = permissions.map(p => `
                <div class="permission-item" data-user-id="${p.user_id}">
                    <span class="permission-user">${escapeHtml(p.display_name || p.username)}</span>
                    <select class="permission-select" onchange="updatePermission(${p.user_id}, this.value)">
                        <option value="viewer" ${p.permission === 'viewer' ? 'selected' : ''}>Viewer</option>
                        <option value="editor" ${p.permission === 'editor' ? 'selected' : ''}>Editor</option>
                    </select>
                    <button class="btn-remove-permission" onclick="removePermission(${p.user_id})" title="Remove">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
            `).join('');
        }

        // User search
        document.getElementById('user-search-input')?.addEventListener('input', function(e) {
            const query = e.target.value.trim();

            clearTimeout(searchTimeout);
            if (query.length < 2) {
                document.getElementById('user-search-results').classList.add('hidden');
                return;
            }

            searchTimeout = setTimeout(() => searchUsers(query), 300);
        });

        // Hide suggestions on blur (with delay to allow clicking on results)
        document.getElementById('user-search-input')?.addEventListener('blur', function() {
            setTimeout(() => {
                document.getElementById('user-search-results').classList.add('hidden');
            }, 200);
        });

        // Show suggestions on focus if there's a query
        document.getElementById('user-search-input')?.addEventListener('focus', function(e) {
            const query = e.target.value.trim();
            if (query.length >= 2) {
                searchUsers(query);
            }
        });

        async function searchUsers(query) {
            try {
                const resp = await fetch(`{{ base_url }}/api/users/search?q=${encodeURIComponent(query)}`);
                const data = await resp.json();
                renderSearchResults(data.users || []);
            } catch (err) {
                console.error('Search failed:', err);
            }
        }

        function renderSearchResults(users) {
            const container = document.getElementById('user-search-results');

            if (users.length === 0) {
                container.innerHTML = '<div class="no-results">No users found</div>';
            } else {
                container.innerHTML = users.map(u => `
                    <div class="search-result-item" onclick="selectUser(${u.id}, '${escapeHtml(u.display_name || u.username)}')">
                        ${escapeHtml(u.display_name || u.username)}
                        <span class="search-result-username">@${escapeHtml(u.username)}</span>
                    </div>
                `).join('');
            }
            container.classList.remove('hidden');
        }

        function selectUser(userId, displayName) {
            selectedUserId = userId;
            document.getElementById('user-search-results').classList.add('hidden');
            document.getElementById('user-search-input').value = '';
            document.getElementById('selected-user-name').textContent = displayName;
            document.getElementById('add-permission-form').classList.remove('hidden');
        }

        document.getElementById('cancel-add-btn')?.addEventListener('click', function() {
            document.getElementById('add-permission-form').classList.add('hidden');
            selectedUserId = null;
        });

        document.getElementById('add-permission-btn')?.addEventListener('click', async function() {
            if (!selectedUserId || !shareModalFolderId) return;

            const permission = document.getElementById('permission-level-select').value;

            try {
                await csrfFetch(`{{ base_url }}/api/folders/${shareModalFolderId}/permissions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: selectedUserId, permission })
                });
                document.getElementById('add-permission-form').classList.add('hidden');
                selectedUserId = null;
                loadPermissions();
            } catch (err) {
                console.error('Add permission failed:', err);
                alert('Failed to add permission');
            }
        });

        async function updatePermission(userId, permission) {
            if (!shareModalFolderId) return;

            try {
                await csrfFetch(`{{ base_url }}/api/folders/${shareModalFolderId}/permissions/${userId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ permission })
                });
            } catch (err) {
                console.error('Update permission failed:', err);
                alert('Failed to update permission');
                loadPermissions();
            }
        }

        async function removePermission(userId) {
            if (!shareModalFolderId) return;
            if (!confirm('Remove access for this user?')) return;

            try {
                await csrfFetch(`{{ base_url }}/api/folders/${shareModalFolderId}/permissions/${userId}`, {
                    method: 'DELETE'
                });
                loadPermissions();
            } catch (err) {
                console.error('Remove permission failed:', err);
                alert('Failed to remove permission');
            }
        }

        // Update sort UI to reflect current sort preference
        function updateSortUI(sortValue) {
            const sortMenu = document.getElementById('sort-menu');
            if (!sortMenu) return;
            
            sortMenu.querySelectorAll('.sort-option').forEach(option => {
                option.classList.toggle('active', option.dataset.sort === sortValue);
            });
        }
        
        // Make updateSortUI available globally for SPA navigation
        window.updateSortUI = updateSortUI;

        // Sort dropdown handler
        const sortBtn = document.getElementById('sort-btn');
        const sortMenu = document.getElementById('sort-menu');

        if (sortBtn && sortMenu) {
            // Toggle menu on button click
            sortBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                sortMenu.classList.toggle('hidden');
            });

            // Handle option selection
            sortMenu.querySelectorAll('.sort-option').forEach(option => {
                option.addEventListener('click', async function() {
                    const sortBy = this.dataset.sort;

                    // Update active state
                    sortMenu.querySelectorAll('.sort-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');
                    sortMenu.classList.add('hidden');

                    // Save preference via API
                    if (currentFolderId) {
                        try {
                            await csrfFetch(`{{ base_url }}/api/folders/${currentFolderId}/sort`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ sort_by: sortBy })
                            });
                        } catch (e) {
                            console.error('Failed to save sort preference:', e);
                        }
                    }

                    // Update URL and reload content via SPA (no page reload)
                    currentSort = sortBy;
                    if (currentFolderId) {
                        navigateToFolder(currentFolderId, true);
                    } else {
                        // Fallback to page reload if no folder context
                        window.location.reload();
                    }
                });
            });

            // Close menu when clicking outside
            document.addEventListener('click', () => {
                sortMenu.classList.add('hidden');
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Load from cache immediately for instant display
            const cachedCollapsed = sessionStorage.getItem('collapsedFoldersCache');
            if (cachedCollapsed) {
                try {
                    collapsedFolders = new Set(JSON.parse(cachedCollapsed));
                } catch (e) {}
            }

            const cachedTree = sessionStorage.getItem('folderTreeCache');
            if (cachedTree) {
                try {
                    folderTree = JSON.parse(cachedTree);
                    window.folderTree = folderTree;
                    renderFolderTree();
                    updateParentSelect();
                } catch (e) {}
            }

            // Fetch fresh data in background (will update if changed)
            loadCollapsedFolders();
            loadFolderTree();
            loadDefaultFolder();
            loadSafes();
        });

        // === Safe Management ===
        let userSafes = [];
        let currentUnlockSafeId = null;
        let currentUnlockSessionKey = null;

        // Safe modal elements
        const safeModal = document.getElementById('safe-modal');
        const safeNameInput = document.getElementById('safe-name-input');
        const safePasswordInput = document.getElementById('safe-password-input');
        const safeWebauthnSelect = document.getElementById('safe-webauthn-select');
        const safeSubmitBtn = document.getElementById('safe-submit-btn');
        
        // Safe unlock modal elements
        const safeUnlockModal = document.getElementById('safe-unlock-modal');
        const safeUnlockTitle = document.getElementById('safe-unlock-title');
        const safeUnlockDescription = document.getElementById('safe-unlock-description');
        const safeUnlockPasswordSection = document.getElementById('safe-unlock-password-section');
        const safeUnlockWebauthnSection = document.getElementById('safe-unlock-webauthn-section');
        const safeUnlockPasswordInput = document.getElementById('safe-unlock-password-input');
        const safeUnlockSubmitBtn = document.getElementById('safe-unlock-submit-btn');

        // Toggle protection type in create modal
        document.querySelectorAll('input[name="safe-protection"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.value === 'password') {
                    document.getElementById('safe-password-section').classList.remove('hidden');
                    document.getElementById('safe-webauthn-section').classList.add('hidden');
                } else {
                    document.getElementById('safe-password-section').classList.add('hidden');
                    document.getElementById('safe-webauthn-section').classList.remove('hidden');
                    loadWebAuthnCredentials();
                }
            });
        });

        async function loadSafes() {
            try {
                const resp = await fetch('{{ base_url }}/api/safes');
                const data = await resp.json();
                userSafes = data.safes || [];
                
                // Sync safe lock status: if server says unlocked but client has no key,
                // the page was reloaded and key is lost. Mark as locked on server too.
                for (const safe of userSafes) {
                    if (safe.is_unlocked && !SafeCrypto.isUnlocked(safe.id)) {
                        console.log(`[loadSafes] Safe ${safe.id} unlocked on server but no client key - syncing lock status`);
                        // Lock on server to sync status
                        try {
                            await csrfFetch(`{{ base_url }}/api/safes/${safe.id}/lock`, { method: 'POST' });
                            safe.is_unlocked = false;
                        } catch (e) {
                            console.error(`[loadSafes] Failed to sync lock status for safe ${safe.id}:`, e);
                        }
                    }
                }
                
                renderFolderTree(); // Re-render to show safes
            } catch (err) {
                console.error('Failed to load safes:', err);
            }
        }

        async function loadWebAuthnCredentials() {
            try {
                const resp = await fetch('{{ base_url }}/api/safes/webauthn/credentials');
                const data = await resp.json();
                
                safeWebauthnSelect.innerHTML = '';
                if (data.credentials && data.credentials.length > 0) {
                    data.credentials.forEach(cred => {
                        const opt = document.createElement('option');
                        opt.value = cred.credential_id;
                        opt.textContent = cred.name;
                        safeWebauthnSelect.appendChild(opt);
                    });
                } else {
                    const opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = 'No hardware keys registered';
                    safeWebauthnSelect.appendChild(opt);
                }
            } catch (err) {
                console.error('Failed to load credentials:', err);
                safeWebauthnSelect.innerHTML = '<option value="">Error loading</option>';
            }
        }

        function openCreateSafe() {
            // Check if SafeCrypto is available
            if (!SafeCrypto.isAvailable) {
                alert('Safe creation requires a secure connection (HTTPS or localhost). Please access this page via https:// or localhost.');
                return;
            }
            
            document.getElementById('safe-modal-title').textContent = 'Create Safe';
            safeNameInput.value = '';
            safePasswordInput.value = '';
            document.querySelector('input[name="safe-protection"][value="password"]').checked = true;
            document.getElementById('safe-password-section').classList.remove('hidden');
            document.getElementById('safe-webauthn-section').classList.add('hidden');
            safeModal.classList.remove('hidden');
            safeNameInput.focus();
        }

        function closeSafeModal() {
            safeModal.classList.add('hidden');
        }

        // Safe Edit Modal functions
        let editingSafeId = null;
        const safeEditModal = document.getElementById('safe-edit-modal');
        const safeEditNameInput = document.getElementById('safe-edit-name-input');
        const safeEditSubmitBtn = document.getElementById('safe-edit-submit-btn');
        const deleteSafeBtn = document.getElementById('delete-safe-btn');

        function openEditSafe(safeId) {
            const safe = userSafes.find(s => s.id === safeId);
            if (!safe) return;

            editingSafeId = safeId;
            document.getElementById('safe-edit-modal-title').textContent = 'Edit Safe';
            safeEditNameInput.value = safe.name;
            
            safeEditModal.classList.remove('hidden');
            safeEditNameInput.focus();
        }

        function closeSafeEditModal() {
            safeEditModal.classList.add('hidden');
            editingSafeId = null;
        }

        // Close modal when clicking outside
        safeEditModal.onclick = (e) => {
            if (e.target === safeEditModal) closeSafeEditModal();
        };

        // Save safe changes
        safeEditSubmitBtn.onclick = async () => {
            if (!editingSafeId) return;

            const name = safeEditNameInput.value.trim();
            if (!name) {
                alert('Please enter a safe name');
                return;
            }

            try {
                await csrfFetch(`{{ base_url }}/api/safes/${editingSafeId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                
                closeSafeEditModal();
                loadSafes();
                loadFolderTree();
                
                // If currently viewing this safe, update the header
                if (window.currentSafeId === editingSafeId) {
                    const folderHeader = document.querySelector('.folder-header');
                    if (folderHeader) {
                        const h2 = folderHeader.querySelector('h2');
                        if (h2) h2.textContent = name;
                    }
                    const folderBreadcrumbs = document.getElementById('folder-breadcrumbs');
                    if (folderBreadcrumbs) {
                        const lastSpan = folderBreadcrumbs.querySelector('span:last-child');
                        if (lastSpan) lastSpan.textContent = name;
                    }
                }
            } catch (err) {
                console.error('Failed to rename safe:', err);
                alert('Failed to rename safe: ' + err.message);
            }
        };

        // Delete safe from edit modal
        deleteSafeBtn.onclick = async () => {
            if (!editingSafeId) return;

            const safe = userSafes.find(s => s.id === editingSafeId);
            if (!safe) return;

            await deleteSafeWithSPA(editingSafeId, safe.name);
        };

        // Toggle password visibility
        window.toggleSafePassword = function(inputId, button) {
            const input = document.getElementById(inputId);
            const isPassword = input.type === 'password';
            input.type = isPassword ? 'text' : 'password';
            
            // Update icon
            button.innerHTML = isPassword 
                ? `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>`
                : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>`;
            button.setAttribute('aria-label', isPassword ? 'Hide password' : 'Show password');
        };

        // Password strength indicator - –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–∂–µ –æ–±—ä—è–≤–ª–µ–Ω–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
        if (safePasswordInput) {
            safePasswordInput.addEventListener('input', function() {
                const value = this.value;
                const strengthBar = document.querySelector('#safe-password-strength .strength-bar');
                if (!strengthBar) return;
                
                let strength = 0;
                if (value.length >= 8) strength++;
                if (value.match(/[a-z]/) && value.match(/[A-Z]/)) strength++;
                if (value.match(/[0-9]/)) strength++;
                if (value.match(/[^a-zA-Z0-9]/)) strength++;
                
                const colors = ['#ff4444', '#ff8800', '#ffcc00', '#44ff44'];
                const widths = ['25%', '50%', '75%', '100%'];
                
                strengthBar.style.width = widths[strength - 1] || '0%';
                strengthBar.style.backgroundColor = colors[strength - 1] || '#444';
            });
        }

        function openSafeUnlock(safeId, safeName, unlockType) {
            currentUnlockSafeId = safeId;
            safeUnlockTitle.textContent = `Unlock "${safeName}"`;
            
            if (unlockType === 'password') {
                safeUnlockDescription.textContent = 'Enter your safe password to unlock';
                safeUnlockPasswordSection.classList.remove('hidden');
                safeUnlockWebauthnSection.classList.add('hidden');
                safeUnlockPasswordInput.value = '';
                safeUnlockPasswordInput.focus();
            } else {
                safeUnlockDescription.textContent = 'Authenticate with your hardware key to unlock';
                safeUnlockPasswordSection.classList.add('hidden');
                safeUnlockWebauthnSection.classList.remove('hidden');
            }
            
            safeUnlockModal.classList.remove('hidden');
        }

        function closeSafeUnlockModal() {
            safeUnlockModal.classList.add('hidden');
            currentUnlockSafeId = null;
            currentUnlockSessionKey = null;
        }

        // Create safe - handle form submit
        document.getElementById('safe-form').addEventListener('submit', async (e) => {
            const name = safeNameInput.value.trim();
            if (!name) {
                alert('Please enter a safe name');
                return;
            }

            const protectionType = document.querySelector('input[name="safe-protection"]:checked').value;
            
            safeSubmitBtn.disabled = true;
            safeSubmitBtn.textContent = 'Creating...';

            try {
                let safeData;
                
                if (protectionType === 'password') {
                    const password = safePasswordInput.value;
                    if (!password || password.length < 8) {
                        alert('Password must be at least 8 characters');
                        safeSubmitBtn.disabled = false;
                        safeSubmitBtn.textContent = 'Create Safe';
                        return;
                    }
                    
                    safeData = await SafeCrypto.createSafeWithPassword(name, password);
                    console.log('[DEBUG] Created safe data:', {
                        name: safeData.name,
                        hasEncryptedDEK: !!safeData.encrypted_dek,
                        hasSalt: !!safeData.salt,
                        saltLength: safeData.salt ? safeData.salt.length : 0
                    });
                } else {
                    const credentialId = safeWebauthnSelect.value;
                    if (!credentialId) {
                        alert('Please select a hardware key');
                        safeSubmitBtn.disabled = false;
                        safeSubmitBtn.textContent = 'Create Safe';
                        return;
                    }
                    
                    safeData = await SafeCrypto.createSafeWithWebAuthn(name, credentialId);
                }

                // Send to server
                const requestBody = {
                    name: safeData.name,
                    unlock_type: protectionType,
                    password: protectionType === 'password' ? safePasswordInput.value : undefined,
                    credential_id: protectionType === 'webauthn' ? safeWebauthnSelect.value : undefined,
                    encrypted_dek: safeData.encrypted_dek,
                    salt: safeData.salt
                };
                console.log('[DEBUG] Sending to server:', {
                    hasEncryptedDEK: !!requestBody.encrypted_dek,
                    hasSalt: !!requestBody.salt,
                    saltLength: requestBody.salt ? requestBody.salt.length : 0
                });
                
                const resp = await csrfFetch('{{ base_url }}/api/safes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!resp.ok) {
                    const err = await resp.json();
                    throw new Error(err.detail || 'Failed to create safe');
                }

                // Complete unlock with session
                const createResult = await resp.json();
                
                await csrfFetch('{{ base_url }}/api/safes/unlock/complete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        safe_id: createResult.safe_id,
                        session_encrypted_dek: safeData.session_encrypted_dek
                    })
                });

                // Store session key locally
                SafeCrypto.storeSafeDEKFromSession(
                    createResult.safe_id,
                    safeData.session_encrypted_dek,
                    safeData.session_key
                );

                closeSafeModal();
                loadSafes();
                // Safe created - user can now create folders via "add folder" button or upload directly to safe
                
            } catch (err) {
                console.error('Create safe failed:', err);
                alert('Failed to create safe: ' + err.message);
            } finally {
                safeSubmitBtn.disabled = false;
                safeSubmitBtn.textContent = 'Create Safe';
            }
        });

        // Unlock safe - handle form submit
        document.getElementById('safe-unlock-form').addEventListener('submit', async (e) => {
            if (!currentUnlockSafeId) return;

            const safe = userSafes.find(s => s.id === currentUnlockSafeId);
            if (!safe) return;

            safeUnlockSubmitBtn.disabled = true;
            safeUnlockSubmitBtn.textContent = 'Unlocking...';

            try {
                if (safe.unlock_type === 'password') {
                    const password = safeUnlockPasswordInput.value;
                    if (!password) {
                        alert('Please enter password');
                        safeUnlockSubmitBtn.disabled = false;
                        safeUnlockSubmitBtn.textContent = 'Unlock';
                        return;
                    }

                    // Get challenge from server
                    const challengeResp = await csrfFetch('{{ base_url }}/api/safes/unlock', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ safe_id: currentUnlockSafeId })
                    });

                    if (!challengeResp.ok) {
                        const errorText = await challengeResp.text();
                        throw new Error(`Server error: ${challengeResp.status} - ${errorText}`);
                    }

                    const challengeData = await challengeResp.json();
                    console.log('Challenge data:', challengeData);
                    
                    if (challengeData.status !== 'challenge') {
                        throw new Error(`Unexpected status: ${challengeData.status}`);
                    }
                    
                    if (!challengeData.encrypted_dek) {
                        throw new Error('Server did not return encrypted_dek');
                    }
                    if (!challengeData.salt) {
                        throw new Error('Server did not return salt');
                    }
                    
                    // Unlock with password
                    const unlockData = await SafeCrypto.unlockWithPassword(
                        currentUnlockSafeId,
                        password,
                        challengeData.encrypted_dek,
                        challengeData.salt
                    );

                    // Complete unlock
                    await csrfFetch('{{ base_url }}/api/safes/unlock/complete', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            safe_id: currentUnlockSafeId,
                            session_encrypted_dek: unlockData.session_encrypted_dek
                        })
                    });

                    // Store locally
                    await SafeCrypto.storeSafeDEKFromSession(
                        currentUnlockSafeId,
                        unlockData.session_encrypted_dek,
                        unlockData.session_key
                    );

                } else {
                    // WebAuthn unlock
                    const challengeResp = await csrfFetch('{{ base_url }}/api/safes/unlock', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ safe_id: currentUnlockSafeId })
                    });

                    const challengeData = await challengeResp.json();
                    
                    // Perform WebAuthn authentication
                    const credential = await navigator.credentials.get({
                        publicKey: {
                            ...challengeData.options,
                            challenge: Uint8Array.from(atob(challengeData.challenge.replace(/-/g, '+').replace(/_/g, '/').padEnd(challengeData.challenge.length + (4 - challengeData.challenge.length % 4) % 4, '=')), c => c.charCodeAt(0))
                        }
                    });

                    // Complete unlock
                    const completeResp = await csrfFetch('{{ base_url }}/api/safes/unlock/complete', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            safe_id: currentUnlockSafeId,
                            credential: {
                                id: credential.id,
                                rawId: btoa(String.fromCharCode(...new Uint8Array(credential.rawId))),
                                response: {
                                    authenticatorData: btoa(String.fromCharCode(...new Uint8Array(credential.response.authenticatorData))),
                                    clientDataJSON: btoa(String.fromCharCode(...new Uint8Array(credential.response.clientDataJSON))),
                                    signature: btoa(String.fromCharCode(...new Uint8Array(credential.response.signature)))
                                },
                                type: credential.type
                            },
                            challenge: challengeData.challenge
                        })
                    });

                    const completeData = await completeResp.json();
                    
                    // Note: For WebAuthn, the server returns the session-encrypted DEK
                    // We need to handle this properly in a real implementation
                }

                closeSafeUnlockModal();
                loadSafes();
                loadFolderTree();
                
                // Refresh safe thumbnails to show decrypted versions
                if (typeof loadSafeThumbnails === 'function') {
                    console.log('[Unlock] Refreshing safe thumbnails');
                    loadSafeThumbnails();
                }
                
                // If there was a pending photo to view, open it now
                if (window.pendingSafePhotoId) {
                    console.log('[Unlock] Opening pending photo:', window.pendingSafePhotoId);
                    const photoId = window.pendingSafePhotoId;
                    window.pendingSafePhotoId = null;
                    // Open the photo in lightbox if function exists
                    if (typeof openPhoto === 'function') {
                        openPhoto(photoId);
                    }
                }
                
            } catch (err) {
                console.error('Unlock failed:', err);
                alert('Unlock failed: ' + err.message);
            } finally {
                safeUnlockSubmitBtn.disabled = false;
                safeUnlockSubmitBtn.textContent = 'Unlock';
            }
        });

        // Delete safe (SPA version - called from edit modal)
        async function deleteSafeWithSPA(safeId, safeName) {
            // Confirm deletion
            const confirmMsg = `Are you sure you want to delete the safe "${safeName}"?\n\n` +
                "This will delete:\n" +
                "- All folders inside the safe\n" +
                "- All photos inside those folders\n\n" +
                "This action cannot be undone!";
            
            if (!confirm(confirmMsg)) {
                return;
            }
            
            // Double-check for photos
            const safeFolders = folderTree.filter(f => f.safe_id === safeId);
            const totalPhotos = safeFolders.reduce((sum, f) => sum + (f.photo_count || 0), 0);
            
            if (totalPhotos > 0) {
                const photoConfirm = `This safe contains ${totalPhotos} photo(s).\n\n` +
                    "Are you absolutely sure you want to delete everything?";
                if (!confirm(photoConfirm)) {
                    return;
                }
            }
            
            try {
                const resp = await csrfFetch(`{{ base_url }}/api/safes/${safeId}`, {
                    method: 'DELETE'
                });
                
                if (!resp.ok) {
                    const err = await resp.json();
                    throw new Error(err.detail || 'Failed to delete safe');
                }
                
                // Clear from local storage
                SafeCrypto.lockSafe(safeId);
                
                // Close edit modal if open
                closeSafeEditModal();
                
                // Refresh UI
                loadSafes();
                loadFolderTree();
                
                // If currently viewing this safe or a folder in it, navigate to default folder
                const currentFolderSafe = getFolderSafeId(window.currentFolderId);
                if (window.currentSafeId === safeId || currentFolderSafe === safeId) {
                    window.currentSafeId = null;
                    navigateToDefaultFolder();
                }
                
            } catch (err) {
                console.error('Delete safe failed:', err);
                alert('Failed to delete safe: ' + err.message);
            }
        }

        // Lock safe
        async function lockSafe(safeId) {
            try {
                await csrfFetch(`{{ base_url }}/api/safes/${safeId}/lock`, {
                    method: 'POST'
                });
                
                SafeCrypto.lockSafe(safeId);
                loadSafes();
                loadFolderTree();
            } catch (err) {
                console.error('Lock failed:', err);
                alert('Failed to lock safe');
            }
        }
        
        // Toggle safe expand/collapse when unlocked
        function toggleSafeExpand(safeId) {
            const safeItem = document.querySelector(`.folder-item.safe-item[data-safe-id="${safeId}"]`);
            if (!safeItem) return;
            
            const wrapper = safeItem.closest('.folder-item-wrapper');
            const isExpanded = safeItem.classList.contains('expanded');
            
            if (isExpanded) {
                // Collapse: remove expanded class and hide folders
                safeItem.classList.remove('expanded');
                const safeFolders = wrapper.parentElement.querySelectorAll(`[data-in-safe="${safeId}"]`);
                safeFolders.forEach(f => f.style.display = 'none');
            } else {
                // Expand: add expanded class and show folders
                safeItem.classList.add('expanded');
                loadSafes(); // Reload to show folders inside safe
            }
        }

        // Create folder in safe
        function openCreateFolderInSafe(safeId) {
            editingFolderId = null;
            folderModalTitle.textContent = 'Create Folder in Safe';
            folderSubmitBtn.textContent = 'Create';
            folderNameInput.value = '';
            folderParentSelect.innerHTML = '<option value="">Root of safe</option>';
            
            // Add folders from this safe as parent options
            const safeFolders = folderTree.filter(f => f.safe_id === safeId);
            safeFolders.forEach(folder => {
                const opt = document.createElement('option');
                opt.value = folder.id;
                opt.textContent = folder.name;
                folderParentSelect.appendChild(opt);
            });
            
            // Store safe_id for submission
            folderModal.dataset.safeId = safeId;
            
            defaultFolderSection.classList.add('hidden');
            deleteFolderSection.classList.add('hidden');
            folderModal.classList.remove('hidden');
            folderNameInput.focus();
        }

        // Modify folder creation to support safe_id
        const originalFolderSubmit = folderSubmitBtn.onclick;
        folderSubmitBtn.onclick = async () => {
            const safeId = folderModal.dataset.safeId;
            if (!safeId) {
                // Regular folder creation
                const name = folderNameInput.value.trim();
                if (!name) {
                    alert('Please enter a folder name');
                    return;
                }

                const parentId = folderParentSelect.value || null;

                try {
                    if (editingFolderId) {
                        await csrfFetch(`{{ base_url }}/api/folders/${editingFolderId}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name })
                        });
                    } else {
                        await csrfFetch('{{ base_url }}/api/folders', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name, parent_id: parentId })
                        });
                    }
                    closeFolderModal();
                    loadFolderTree();
                } catch (err) {
                    console.error('Folder operation failed:', err);
                    alert('Operation failed');
                }
                return;
            }

            // Safe folder creation
            const name = folderNameInput.value.trim();
            if (!name) {
                alert('Please enter a folder name');
                return;
            }

            const parentId = folderParentSelect.value || null;

            try {
                await csrfFetch('{{ base_url }}/api/folders', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, parent_id: parentId, safe_id: safeId })
                });
                closeFolderModal();
                folderModal.dataset.safeId = '';
                loadFolderTree();
            } catch (err) {
                console.error('Folder creation failed:', err);
                alert('Operation failed: ' + err.message);
            }
        };
    </script>

    {% block scripts %}{% endblock %}
</body>
</html>
